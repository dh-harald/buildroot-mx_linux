commit 9422365b532d55f45e887010382edc51911df082
Author: Stanislav Vlasic <svlasic@gmail.com>
Date:   Sun Nov 3 17:26:00 2013 +0100

    [ffmpeg] Bump version to 1.2.4 with applied patches

diff --git a/lib/ffmpeg/.gitignore b/lib/ffmpeg/.gitignore
deleted file mode 100644
index 9b935c7..0000000
--- a/lib/ffmpeg/.gitignore
+++ /dev/null
@@ -1,70 +0,0 @@
-*.a
-*.o
-*.d
-*.def
-*.dll
-*.dylib
-*.exe
-*.exp
-*.h.c
-*.ilk
-*.lib
-*.pc
-*.pdb
-*.so
-*.so.*
-*.ver
-*-example
-*-test
-*_g
-/.config
-/.version
-/ffmpeg
-/ffplay
-/ffprobe
-/ffserver
-/config.*
-/version.h
-/doc/*.1
-/doc/*.3
-/doc/*.html
-/doc/*.pod
-/doc/avoptions_codec.texi
-/doc/avoptions_format.texi
-/doc/examples/decoding_encoding
-/doc/examples/demuxing
-/doc/examples/filtering_audio
-/doc/examples/filtering_video
-/doc/examples/metadata
-/doc/examples/muxing
-/doc/examples/pc-uninstalled
-/doc/examples/resampling_audio
-/doc/examples/scaling_video
-/doc/fate.txt
-/doc/doxy/html/
-/doc/print_options
-/libavcodec/*_tablegen
-/libavcodec/*_tables.c
-/libavcodec/*_tables.h
-/libavutil/avconfig.h
-/tests/audiogen
-/tests/base64
-/tests/data/
-/tests/rotozoom
-/tests/tiny_psnr
-/tests/videogen
-/tests/vsynth1/
-/tools/aviocat
-/tools/ffbisect
-/tools/bisect.need
-/tools/cws2fws
-/tools/fourcc2pixfmt
-/tools/ffescape
-/tools/ffeval
-/tools/graph2dot
-/tools/ismindex
-/tools/pktdumper
-/tools/probetest
-/tools/qt-faststart
-/tools/trasher
-/tools/seek_print
diff --git a/lib/ffmpeg/RELEASE b/lib/ffmpeg/RELEASE
index 5625e59..e8ea05d 100644
--- a/lib/ffmpeg/RELEASE
+++ b/lib/ffmpeg/RELEASE
@@ -1 +1 @@
-1.2
+1.2.4
diff --git a/lib/ffmpeg/VERSION b/lib/ffmpeg/VERSION
index abca3ab..e8ea05d 100644
--- a/lib/ffmpeg/VERSION
+++ b/lib/ffmpeg/VERSION
@@ -1 +1 @@
-1.2-xbmc
+1.2.4
diff --git a/lib/ffmpeg/build_xbmc_win32.sh b/lib/ffmpeg/build_xbmc_win32.sh
index dbc1b3e..fdb00c6 100755
--- a/lib/ffmpeg/build_xbmc_win32.sh
+++ b/lib/ffmpeg/build_xbmc_win32.sh
@@ -1,24 +1,11 @@
 #!/bin/bash
 
-MAKEFLAGS=""
-BGPROCESSFILE="$2"
-
-if [ "$1" == "clean" ]
-then
-  if [ -d .libs ]
-  then
-    rm -r .libs
-  fi
-  mingw32-make distclean
-fi
+#
+# build_xbmc_win32.sh (v1.1)
+# Version agnostic win32 build script adjusted for ffmpeg n1.1 and onwards...
+# 
 
-if [ $NUMBER_OF_PROCESSORS > 1 ]; then
-  MAKEFLAGS=-j$NUMBER_OF_PROCESSORS
-fi
-
-if [ ! -d .libs ]; then
-  mkdir .libs
-fi
+MAKEFLAGS=""
 
 # add --enable-debug (remove --disable-debug ofc) to get ffmpeg log messages in xbmc.log
 # the resulting debug dll's are twice to fourth time the size of the release binaries
@@ -47,21 +34,98 @@ OPTIONS="
 --enable-encoder=aac \
 --enable-runtime-cpudetect \
 --enable-avfilter \
---enable-dxva2 \
---enable-gnutls \
 --disable-doc"
 
-./configure --extra-cflags="-fno-common -Iinclude-xbmc-win32/dxva2 -DNDEBUG" --extra-ldflags="-L/xbmc/system/players/dvdplayer" ${OPTIONS} &&
- 
-mingw32-make $MAKEFLAGS &&
-cp lib*/*.dll .libs/ &&
-cp .libs/avcodec-54.dll /xbmc/system/players/dvdplayer/ &&
-cp .libs/avformat-54.dll /xbmc/system/players/dvdplayer/ &&
-cp .libs/avutil-52.dll /xbmc/system/players/dvdplayer/ &&
-cp .libs/avfilter-3.dll /xbmc/system/players/dvdplayer/ &&
-cp .libs/postproc-52.dll /xbmc/system/players/dvdplayer/ &&
-cp .libs/swresample-0.dll /xbmc/system/players/dvdplayer/ &&
-cp .libs/swscale-2.dll /xbmc/system/players/dvdplayer/
-
-#remove the bgprocessfile for signaling the process end
-rm $BGPROCESSFILE
+#
+# Flag when ffmpeg is configured 
+#
+
+WIN32CONF=.win32configured
+DLLPATHS_INCLUDE=/xbmc/xbmc/DllPaths_generated_win32_ffmpeg.h
+
+
+#
+# Set parallel build mode
+#
+
+if [ $NUMBER_OF_PROCESSORS > 1 ]
+then
+  MAKEFLAGS=-j$NUMBER_OF_PROCESSORS
+fi
+
+
+#
+# Clean object files and libraries
+#
+
+if [ "$1" == "clean" ]
+then
+  make distclean
+  rm -f $WIN32CONF $DLLPATHS_INCLUDE
+fi
+
+
+#
+# Only run configure when neccesary and break if configure fails.
+#
+
+if [ ! -f $WIN32CONF ]; then
+
+  echo "$0: Running ffmpeg configure..."
+
+  if ./configure --extra-cflags="-fno-common -Iinclude-xbmc-win32/dxva2 -DNDEBUG" \
+				--extra-ldflags="-L/xbmc/system/players/dvdplayer" ${OPTIONS}; then
+	touch $WIN32CONF
+  else
+	echo "$0: configure failed."
+	exit 1
+  fi
+fi
+
+
+#
+# version agnostic build, copy and generate DLL-paths include file.
+# 
+
+# enable break on error:
+set -e
+
+make $MAKEFLAGS 
+
+DLL_PATH_LIBAVCODEC=$(set -- libavcodec/avcodec-[0-9]*.dll; echo $1)
+DLL_PATH_LIBAVFORMAT=$(set -- libavformat/avformat-[0-9]*.dll; echo $1)
+DLL_PATH_LIBAVUTIL=$(set -- libavutil/avutil-[0-9]*.dll; echo $1)
+DLL_PATH_LIBAVFILTER=$(set -- libavfilter/avfilter-[0-9]*.dll; echo $1)
+DLL_PATH_LIBPOSTPROC=$(set -- libpostproc/postproc-[0-9]*.dll; echo $1)
+DLL_PATH_LIBSWSCALE=$(set -- libswscale/swscale-[0-9]*.dll; echo $1)
+DLL_PATH_LIBSWRESAMPLE=$(set -- libswresample/swresample-[0-9]*.dll; echo $1)
+
+#
+# Generate dll path defintion file $DLLPATHS_INCLUDE
+#
+
+cat <<EOF > $DLLPATHS_INCLUDE
+/*
+** Definitions auto generated by $0 
+** Date: $(date)
+*/
+EOF
+
+for DLL in	DLL_PATH_LIBAVCODEC DLL_PATH_LIBAVFORMAT DLL_PATH_LIBAVUTIL \
+		DLL_PATH_LIBAVFILTER DLL_PATH_LIBPOSTPROC DLL_PATH_LIBSWSCALE \
+		DLL_PATH_LIBSWRESAMPLE
+do
+	echo "#define $DLL		\"special://xbmcbin/system/players/dvdplayer/$(basename ${!DLL})\""
+done >> $DLLPATHS_INCLUDE
+
+#
+# Copy dll's to system player folder
+#
+
+cp $DLL_PATH_LIBAVCODEC		/xbmc/system/players/dvdplayer/
+cp $DLL_PATH_LIBAVFORMAT	/xbmc/system/players/dvdplayer/
+cp $DLL_PATH_LIBAVUTIL		/xbmc/system/players/dvdplayer/ 
+cp $DLL_PATH_LIBAVFILTER	/xbmc/system/players/dvdplayer/ 
+cp $DLL_PATH_LIBPOSTPROC	/xbmc/system/players/dvdplayer/ 
+cp $DLL_PATH_LIBSWSCALE		/xbmc/system/players/dvdplayer/ 
+cp $DLL_PATH_LIBSWRESAMPLE	/xbmc/system/players/dvdplayer/ 
diff --git a/lib/ffmpeg/cmdutils.h b/lib/ffmpeg/cmdutils.h
index 08c92ce..6341a2f 100644
--- a/lib/ffmpeg/cmdutils.h
+++ b/lib/ffmpeg/cmdutils.h
@@ -190,13 +190,13 @@ void show_help_options(const OptionDef *options, const char *msg, int req_flags,
 void show_help_children(const AVClass *class, int flags);
 
 /**
- * Per-avtool specific help handler. Implemented in each
- * avtool, called by show_help().
+ * Per-fftool specific help handler. Implemented in each
+ * fftool, called by show_help().
  */
 void show_help_default(const char *opt, const char *arg);
 
 /**
- * Generic -h handler common to all avtools.
+ * Generic -h handler common to all fftools.
  */
 int show_help(void *optctx, const char *opt, const char *arg);
 
diff --git a/lib/ffmpeg/configure b/lib/ffmpeg/configure
index 351611d..1f833e2 100755
--- a/lib/ffmpeg/configure
+++ b/lib/ffmpeg/configure
@@ -140,10 +140,10 @@ Component options:
   --disable-fft            disable FFT code
 
 Hardware accelerators:
-  --enable-dxva2           enable DXVA2 code
-  --enable-vaapi           enable VAAPI code
+  --disable-dxva2          disable DXVA2 code [autodetect]
+  --disable-vaapi          disable VAAPI code [autodetect]
   --enable-vda             enable VDA code
-  --enable-vdpau           enable VDPAU code
+  --disable-vdpau          disable VDPAU code [autodetect]
 
 Individual component options:
   --disable-everything     disable all components listed below
@@ -184,11 +184,11 @@ Individual component options:
 
 External library support:
   --enable-avisynth        enable reading of AVISynth script files [no]
-  --enable-bzlib           enable bzlib [autodetect]
+  --disable-bzlib          disable bzlib [autodetect]
   --enable-fontconfig      enable fontconfig
   --enable-frei0r          enable frei0r video filtering
   --enable-gnutls          enable gnutls [no]
-  --enable-iconv           enable iconv [autodetect]
+  --disable-iconv          disable iconv [autodetect]
   --enable-libaacplus      enable AAC+ encoding via libaacplus [no]
   --enable-libass          enable libass subtitles rendering [no]
   --enable-libbluray       enable BluRay reading using libbluray [no]
@@ -235,7 +235,7 @@ External library support:
   --enable-openal          enable OpenAL 1.1 capture support [no]
   --enable-openssl         enable openssl [no]
   --enable-x11grab         enable X11 grabbing [no]
-  --enable-zlib            enable zlib [autodetect]
+  --disable-zlib           disable zlib [autodetect]
 
 Advanced options (experts only):
   --cross-prefix=PREFIX    use PREFIX for compilation tools [$cross_prefix]
@@ -2171,6 +2171,9 @@ enable safe_bitstream_reader
 enable static
 enable swscale_alpha
 
+# Enable hwaccels by default.
+enable dxva2 vaapi vdpau
+
 # build settings
 SHFLAGS='-shared -Wl,-soname,$$(@F)'
 FFSERVERLDFLAGS=-Wl,-E
@@ -3879,7 +3882,6 @@ fi
 
 check_lib math.h sin -lm && LIBM="-lm"
 disabled crystalhd || check_lib libcrystalhd/libcrystalhd_if.h DtsCrystalHDVersion -lcrystalhd || disable crystalhd
-enabled vaapi && require vaapi va/va.h vaInitialize -lva
 
 atan2f_args=2
 ldexpf_args=2
@@ -4047,12 +4049,9 @@ require X11 X11/Xlib.h XOpenDisplay -lX11                 &&
 require Xext X11/extensions/XShm.h XShmCreateImage -lXext &&
 require Xfixes X11/extensions/Xfixes.h XFixesGetCursorImage -lXfixes
 
-if ! disabled vaapi; then
-    check_lib va/va.h vaInitialize -lva && {
-        check_cpp_condition va/va_version.h "VA_CHECK_VERSION(0,32,0)" ||
-        warn "Please upgrade to VA-API >= 0.32 if you would like full VA-API support.";
-    } || disable vaapi
-fi
+enabled vaapi &&
+    check_lib va/va.h vaInitialize -lva ||
+    disable vaapi
 
 enabled vdpau &&
     check_cpp_condition vdpau/vdpau.h "defined VDP_DECODER_PROFILE_MPEG4_PART2_ASP" ||
diff --git a/lib/ffmpeg/doc/Doxyfile b/lib/ffmpeg/doc/Doxyfile
index 55dd7a7..6740e77 100644
--- a/lib/ffmpeg/doc/Doxyfile
+++ b/lib/ffmpeg/doc/Doxyfile
@@ -31,7 +31,7 @@ PROJECT_NAME           = FFmpeg
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 1.2
+PROJECT_NUMBER         = 1.2.4
 
 # With the PROJECT_LOGO tag one can specify an logo or icon that is included
 # in the documentation. The maximum height of the logo should not exceed 55
diff --git a/lib/ffmpeg/doc/decoders.texi b/lib/ffmpeg/doc/decoders.texi
index 2d812a2..cdcbe65 100644
--- a/lib/ffmpeg/doc/decoders.texi
+++ b/lib/ffmpeg/doc/decoders.texi
@@ -60,6 +60,78 @@ This decoder generates wave patterns according to predefined sequences. Its
 use is purely internal and the format of the data it accepts is not publicly
 documented.
 
+@section libcelt
+
+libcelt decoder wrapper
+
+libcelt allows libavcodec to decode the Xiph CELT ultra-low delay audio codec.
+Requires the presence of the libcelt headers and library during configuration.
+You need to explicitly configure the build with @code{--enable-libcelt}.
+
+@section libgsm
+
+libgsm decoder wrapper
+
+libgsm allows libavcodec to decode the GSM full rate audio codec. Requires
+the presence of the libgsm headers and library during configuration. You need
+to explicitly configure the build with @code{--enable-libgsm}.
+
+This decoder supports both the ordinary GSM and the Microsoft variant.
+
+@section libilbc
+
+libilbc decoder wrapper
+
+libilbc allows libavcodec to decode the Internet Low Bitrate Codec (iLBC)
+audio codec. Requires the presence of the libilbc headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libilbc}.
+
+@subsection Options
+
+The following option is supported by the libilbc wrapper.
+
+@table @option
+@item enhance
+
+Enable the enhancement of the decoded audio when set to 1. The default
+value is 0 (disabled).
+
+@end table
+
+@section libopencore-amrnb
+
+libopencore-amrnb decoder wrapper
+
+libopencore-amrnb allows libavcodec to decode the Adaptive Multi-Rate
+Narrowband audio codec. Using it requires the presence of the
+libopencore-amrnb headers and library during configuration. You need to
+explicitly configure the build with @code{--enable-libopencore-amrnb}.
+
+An FFmpeg native decoder for AMR-NB exists, so users can decode AMR-NB
+without this library.
+
+@section libopencore-amrwb
+
+libopencore-amrwb decoder wrapper.
+
+libopencore-amrwb allows libavcodec to decode the Adaptive Multi-Rate
+Wideband audio codec. Using it requires the presence of the
+libopencore-amrwb headers and library during configuration. You need to
+explicitly configure the build with @code{--enable-libopencore-amrwb}.
+
+An FFmpeg native decoder for AMR-WB exists, so users can decode AMR-WB
+without this library.
+
+@section libopus
+
+libopus decoder wrapper.
+
+libopus allows libavcodec to decode the Opus Interactive Audio Codec.
+Requires the presence of the libopus headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libopus}.
+
 @c man end AUDIO DECODERS
 
 @chapter Subtitles Decoders
diff --git a/lib/ffmpeg/doc/encoders.texi b/lib/ffmpeg/doc/encoders.texi
index 07343eb..a2ad496 100644
--- a/lib/ffmpeg/doc/encoders.texi
+++ b/lib/ffmpeg/doc/encoders.texi
@@ -25,6 +25,95 @@ enabled encoders.
 A description of some of the currently available audio encoders
 follows.
 
+@anchor{aacenc}
+@section aac
+
+Advanced Audio Coding (AAC) encoder.
+
+This encoder is an experimental FFmpeg-native AAC encoder. Currently only the
+low complexity (AAC-LC) profile is supported. To use this encoder, you must set
+@option{strict} option to @samp{experimental} or lower.
+
+As this encoder is experimental, unexpected behavior may exist from time to
+time. For a more stable AAC encoder, see @ref{libvo-aacenc}. However, be warned
+that it has a worse quality reported by some users.
+
+@c Comment this out until somebody writes the respective documentation.
+@c See also @ref{libfaac}, @ref{libaacplus}, and @ref{libfdk-aac-enc}.
+
+@subsection Options
+
+@table @option
+@item b
+Set bit rate in bits/s. Setting this automatically activates constant bit rate
+(CBR) mode.
+
+@item q
+Set quality for variable bit rate (VBR) mode. This option is valid only using
+the @command{ffmpeg} command-line tool. For library interface users, use
+@option{global_quality}.
+
+@item stereo_mode
+Set stereo encoding mode. Possible values:
+
+@table @samp
+@item auto
+Automatically selected by the encoder.
+
+@item ms_off
+Disable middle/side encoding. This is the default.
+
+@item ms_force
+Force middle/side encoding.
+@end table
+
+@item aac_coder
+Set AAC encoder coding method. Possible values:
+
+@table @samp
+@item 0
+FAAC-inspired method.
+
+This method is a simplified reimplementation of the method used in FAAC, which
+sets thresholds proportional to the band energies, and then decreases all the
+thresholds with quantizer steps to find the appropriate quantization with
+distortion below threshold band by band.
+
+The quality of this method is comparable to the two loop searching method
+descibed below, but somewhat a little better and slower.
+
+@item 1
+Average noise to mask ratio (ANMR) trellis-based solution.
+
+This has a theoretic best quality out of all the coding methods, but at the
+cost of the slowest speed.
+
+@item 2
+Two loop searching (TLS) method.
+
+This method first sets quantizers depending on band thresholds and then tries
+to find an optimal combination by adding or subtracting a specific value from
+all quantizers and adjusting some individual quantizer a little.
+
+This method produces similar quality with the FAAC method and is the default.
+
+@item 3
+Constant quantizer method.
+
+This method sets a constant quantizer for all bands. This is the fastest of all
+the methods, yet produces the worst quality.
+
+@end table
+
+@end table
+
+@subsection Tips and Tricks
+
+According to some reports
+(e.g. @url{http://d.hatena.ne.jp/kamedo2/20120729/1343545890}), setting the
+@option{cutoff} option to 15000 Hz greatly improves the quality of the output
+quality. As a result, we encourage you to do the same.
+
 @section ac3 and ac3_fixed
 
 AC-3 audio encoders.
@@ -412,6 +501,279 @@ Selected by Encoder (default)
 
 @end table
 
+@section libmp3lame
+
+LAME (Lame Ain't an MP3 Encoder) MP3 encoder wrapper
+
+Requires the presence of the libmp3lame headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libmp3lame}.
+
+@subsection Options
+
+The following options are supported by the libmp3lame wrapper. The
+@command{lame}-equivalent of the options are listed in parentheses.
+
+@table @option
+@item b (@emph{-b})
+Set bitrate expressed in bits/s for CBR. LAME @code{bitrate} is
+expressed in kilobits/s.
+
+@item q (@emph{-V})
+Set constant quality setting for VBR. This option is valid only
+using the @command{ffmpeg} command-line tool. For library interface
+users, use @option{global_quality}.
+
+@item compression_level (@emph{-q})
+Set algorithm quality. Valid arguments are integers in the 0-9 range,
+with 0 meaning highest quality but slowest, and 9 meaning fastest
+while producing the worst quality.
+
+@item reservoir
+Enable use of bit reservoir when set to 1. Default value is 1. LAME
+has this enabled by default, but can be overriden by use
+@option{--nores} option.
+
+@end table
+
+@section libopencore-amrnb
+
+OpenCORE Adaptive Multi-Rate Narrowband encoder.
+
+Requires the presence of the libopencore-amrnb headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libopencore-amrnb --enable-version3}.
+
+This is a mono-only encoder. Officially it only supports 8000Hz sample rate,
+but you can override it by setting @option{strict} to @samp{unofficial} or
+lower.
+
+@subsection Options
+
+@table @option
+
+@item b
+Set bitrate in bits per second. Only the following bitrates are supported,
+otherwise libavcodec will round to the nearest valid bitrate.
+
+@table @option
+@item 4750
+@item 5150
+@item 5900
+@item 6700
+@item 7400
+@item 7950
+@item 10200
+@item 12200
+@end table
+
+@item dtx
+Allow discontinuous transmission (generate comfort noise) when set to 1. The
+default value is 0 (disabled).
+
+@end table
+
+@section libtwolame
+
+TwoLAME MP2 encoder wrapper
+
+Requires the presence of the libtwolame headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libtwolame}.
+
+@subsection Options
+
+The following options are supported by the libtwolame wrapper. The
+@command{twolame}-equivalent options follow the FFmpeg ones and are in
+parentheses.
+
+@table @option
+@item b (@emph{-b})
+Set bitrate expressed in bits/s for CBR. @command{twolame} @option{b}
+option is expressed in kilobits/s. Default value is 128k.
+
+@item q (@emph{-V})
+Set quality for experimental VBR support. Maximum value range is
+from -50 to 50, useful range is from -10 to 10. The higher the
+value, the better the quality. This option is valid only using the
+@command{ffmpeg} command-line tool. For library interface users,
+use @option{global_quality}.
+
+@item mode (@emph{--mode})
+Set the mode of the resulting audio. Possible values:
+
+@table @samp
+@item auto
+Choose mode automatically based on the input. This is the default.
+@item stereo
+Stereo
+@item joint_stereo
+Joint stereo
+@item dual_channel
+Dual channel
+@item mono
+Mono
+@end table
+
+@item psymodel (@emph{--psyc-mode})
+Set psychoacoustic model to use in encoding. The argument must be
+an integer between -1 and 4, inclusive. The higher the value, the
+better the quality. The default value is 3.
+
+@item energy_levels (@emph{--energy})
+Enable energy levels extensions when set to 1. The default value is
+0 (disabled).
+
+@item error_protection (@emph{--protect})
+Enable CRC error protection when set to 1. The default value is 0
+(disabled).
+
+@item copyright (@emph{--copyright})
+Set MPEG audio copyright flag when set to 1. The default value is 0
+(disabled).
+
+@item original (@emph{--original})
+Set MPEG audio original flag when set to 1. The default value is 0
+(disabled).
+
+@end table
+
+@anchor{libvo-aacenc}
+@section libvo-aacenc
+
+VisualOn AAC encoder
+
+Requires the presence of the libvo-aacenc headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libvo-aacenc --enable-version3}.
+
+This encoder is considered to be worse than the
+@ref{aacenc,,native experimental FFmpeg AAC encoder}, according to
+multiple sources.
+
+@subsection Options
+
+The VisualOn AAC encoder only support encoding AAC-LC and up to 2
+channels. It is also CBR-only.
+
+@table @option
+
+@item b
+Set bit rate in bits/s.
+
+@end table
+
+@section libvo-amrwbenc
+
+VisualOn Adaptive Multi-Rate Wideband encoder
+
+Requires the presence of the libvo-amrwbenc headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libvo-amrwbenc --enable-version3}.
+
+This is a mono-only encoder. Officially it only supports 16000Hz sample
+rate, but you can override it by setting @option{strict} to
+@samp{unofficial} or lower.
+
+@subsection Options
+
+@table @option
+
+@item b
+Set bitrate in bits/s. Only the following bitrates are supported, otherwise
+libavcodec will round to the nearest valid bitrate.
+
+@table @samp
+@item 6600
+@item 8850
+@item 12650
+@item 14250
+@item 15850
+@item 18250
+@item 19850
+@item 23050
+@item 23850
+@end table
+
+@item dtx
+Allow discontinuous transmission (generate comfort noise) when set to 1. The
+default value is 0 (disabled).
+
+@end table
+
+@section libopus
+
+libopus Opus Interactive Audio Codec encoder wrapper.
+
+Requires the presence of the libopus headers and library during
+configuration. You need to explicitly configure the build with
+@code{--enable-libopus}.
+
+@subsection Option Mapping
+
+Most libopus options are modeled after the @command{opusenc} utility from
+opus-tools. The following is an option mapping chart describing options
+supported by the libopus wrapper, and their @command{opusenc}-equivalent
+in parentheses.
+
+@table @option
+
+@item b (@emph{bitrate})
+Set the bit rate in bits/s.  FFmpeg's @option{b} option is
+expressed in bits/s, while @command{opusenc}'s @option{bitrate} in
+kilobits/s.
+
+@item vbr (@emph{vbr}, @emph{hard-cbr}, and @emph{cvbr})
+Set VBR mode. The FFmpeg @option{vbr} option has the following
+valid arguments, with the their @command{opusenc} equivalent options
+in parentheses:
+
+@table @samp
+@item off (@emph{hard-cbr})
+Use constant bit rate encoding.
+
+@item on (@emph{vbr})
+Use variable bit rate encoding (the default).
+
+@item constrained (@emph{cvbr})
+Use constrained variable bit rate encoding.
+@end table
+
+@item compression_level (@emph{comp})
+Set encoding algorithm complexity. Valid options are integers in
+the 0-10 range. 0 gives the fastest encodes but lower quality, while 10
+gives the highest quality but slowest encoding. The default is 10.
+
+@item frame_duration (@emph{framesize})
+Set maximum frame size, or duration of a frame in milliseconds. The
+argument must be exactly the following: 2.5, 5, 10, 20, 40, 60. Smaller
+frame sizes achieve lower latency but less quality at a given bitrate.
+Sizes greater than 20ms are only interesting at fairly low bitrates.
+The default of FFmpeg is 10ms, but is 20ms in @command{opusenc}.
+
+@item packet_loss (@emph{expect-loss})
+Set expected packet loss percentage. The default is 0.
+
+@item application (N.A.)
+Set intended application type. Valid options are listed below:
+
+@table @samp
+@item voip
+Favor improved speech intelligibility.
+@item audio
+Favor faithfulness to the input (the default).
+@item lowdelay
+Restrict to only the lowest delay modes.
+@end table
+
+@item cutoff (N.A.)
+Set cutoff bandwidth in Hz. The argument must be exactly one of the
+following: 4000, 6000, 8000, 12000, or 20000, corresponding to
+narrowband, mediumband, wideband, super wideband, and fullband
+respectively. The default is 0 (cutoff disabled).
+
+@end table
+
 @c man end AUDIO ENCODERS
 
 @chapter Video Encoders
@@ -583,178 +945,318 @@ For more information about libvpx see:
 
 x264 H.264/MPEG-4 AVC encoder wrapper
 
-Requires the presence of the libx264 headers and library during
-configuration. You need to explicitly configure the build with
+This encoder requires the presence of the libx264 headers and library
+during configuration. You need to explicitly configure the build with
 @code{--enable-libx264}.
 
-x264 supports an impressive number of features, including 8x8 and 4x4 adaptive
-spatial transform, adaptive B-frame placement, CAVLC/CABAC entropy coding,
-interlacing (MBAFF), lossless mode, psy optimizations for detail retention
-(adaptive quantization, psy-RD, psy-trellis).
+libx264 supports an impressive number of features, including 8x8 and
+4x4 adaptive spatial transform, adaptive B-frame placement, CAVLC/CABAC
+entropy coding, interlacing (MBAFF), lossless mode, psy optimizations
+for detail retention (adaptive quantization, psy-RD, psy-trellis).
 
-The FFmpeg wrapper provides a mapping for most of them using global options
-that match those of the encoders and provides private options for the unique
-encoder options. Additionally an expert override is provided to directly pass
-a list of key=value tuples as accepted by x264_param_parse.
+Many libx264 encoder options are mapped to FFmpeg global codec
+options, while unique encoder options are provided through private
+options. Additionally the @option{x264opts} and @option{x264-params}
+private options allows to pass a list of key=value tuples as accepted
+by the libx264 @code{x264_param_parse} function.
 
-@subsection Option Mapping
+The x264 project website is at
+@url{http://www.videolan.org/developers/x264.html}.
+
+@subsection Options
+
+The following options are supported by the libx264 wrapper. The
+@command{x264}-equivalent options or values are listed in parentheses
+for easy migration.
+
+To reduce the duplication of documentation, only the private options
+and some others requiring special attention are documented here. For
+the documentation of the undocumented generic options, see
+@ref{codec-options,,the Codec Options chapter}.
+
+To get a more accurate and extensive documentation of the libx264
+options, invoke the command @command{x264 --full-help} or consult
+the libx264 documentation.
+
+@table @option
+@item b (@emph{bitrate})
+Set bitrate in bits/s. Note that FFmpeg's @option{b} option is
+expressed in bits/s, while @command{x264}'s @option{bitrate} is in
+kilobits/s.
+
+@item bf (@emph{bframes})
+
+@item g (@emph{keyint})
+
+@item qmax (@emph{qpmax})
+
+@item qmin (@emph{qpmin})
+
+@item qdiff (@emph{qpstep})
+
+@item qblur (@emph{qblur})
+
+@item qcomp (@emph{qcomp})
+
+@item refs (@emph{ref})
+
+@item sc_threshold (@emph{scenecut})
+
+@item trellis (@emph{trellis})
+
+@item nr  (@emph{nr})
+
+@item me_range (@emph{merange})
+
+@item me_method (@emph{me})
+Set motion estimation method. Possible values in the decreasing order
+of speed:
+
+@table @samp
+@item dia (@emph{dia})
+@item epzs (@emph{dia})
+Diamond search with radius 1 (fastest). @samp{epzs} is an alias for
+@samp{dia}.
+@item hex (@emph{hex})
+Hexagonal search with radius 2.
+@item umh (@emph{umh})
+Uneven multi-hexagon search.
+@item esa (@emph{esa})
+Exhaustive search.
+@item tesa (@emph{tesa})
+Hadamard exhaustive search (slowest).
+@end table
+
+@item subq (@emph{subme})
+
+@item b_strategy (@emph{b-adapt})
+
+@item keyint_min (@emph{min-keyint})
 
-The following options are supported by the x264 wrapper, the x264-equivalent
-options follow the FFmpeg ones.
-
-@multitable @columnfractions .2 .2
-@item b                 @tab bitrate
-FFmpeg @code{b} option is expressed in bits/s, x264 @code{bitrate} in kilobits/s.
-@item bf                @tab bframes
-Maximum number of B-frames.
-@item g                 @tab keyint
-Maximum GOP size.
-@item qmin              @tab qpmin
-@item qmax              @tab qpmax
-@item qdiff             @tab qpstep
-@item qblur             @tab qblur
-@item qcomp             @tab qcomp
-@item refs              @tab ref
-@item sc_threshold      @tab scenecut
-@item trellis           @tab trellis
-@item nr                @tab nr
-Noise reduction.
-@item me_range          @tab merange
-@item me_method         @tab me
-@item subq              @tab subme
-@item b_strategy        @tab b-adapt
-@item keyint_min        @tab keyint-min
-@item coder             @tab cabac
-Set coder to @code{ac} to use CABAC.
-@item cmp               @tab chroma-me
-Set to @code{chroma} to use chroma motion estimation.
-@item threads           @tab threads
-@item thread_type       @tab sliced_threads
-Set to @code{slice} to use sliced threading instead of frame threading.
-@item flags -cgop       @tab open-gop
-Set @code{-cgop} to use recovery points to close GOPs.
-@item rc_init_occupancy @tab vbv-init
-Initial buffer occupancy.
-@end multitable
-
-@subsection Private Options
-@table @option
-@item -preset @var{string}
-Set the encoding preset (cf. x264 --fullhelp).
-@item -tune @var{string}
-Tune the encoding params (cf. x264 --fullhelp).
-@item -profile @var{string}
-Set profile restrictions (cf. x264 --fullhelp).
-@item -fastfirstpass @var{integer}
-Use fast settings when encoding first pass.
-@item -crf @var{float}
-Select the quality for constant quality mode.
-@item -crf_max @var{float}
+@item coder
+Set entropy encoder. Possible values:
+
+@table @samp
+@item ac
+Enable CABAC.
+
+@item vlc
+Enable CAVLC and disable CABAC. It generates the same effect as
+@command{x264}'s @option{--no-cabac} option.
+@end table
+
+@item cmp
+Set full pixel motion estimation comparation algorithm. Possible values:
+
+@table @samp
+@item chroma
+Enable chroma in motion estimation.
+
+@item sad
+Ignore chroma in motion estimation. It generates the same effect as
+@command{x264}'s @option{--no-chroma-me} option.
+@end table
+
+@item threads (@emph{threads})
+
+@item thread_type
+Set multithreading technique. Possible values:
+
+@table @samp
+@item slice
+Slice-based multithreading. It generates the same effect as
+@command{x264}'s @option{--sliced-threads} option.
+@item frame
+Frame-based multithreading.
+@end table
+
+@item flags
+Set encoding flags. It can be used to disable closed GOP and enable
+open GOP by setting it to @code{-cgop}. The result is similar to
+the behavior of @command{x264}'s @option{--open-gop} option.
+
+@item rc_init_occupancy (@emph{vbv-init})
+
+@item preset (@emph{preset})
+Set the encoding preset.
+
+@item tune (@emph{tune})
+Set tuning of the encoding params.
+
+@item profile (@emph{profile})
+Set profile restrictions.
+
+@item fastfirstpass
+Enable fast settings when encoding first pass, when set to 1. When set
+to 0, it has the same effect of @command{x264}'s
+@option{--slow-firstpass} option.
+
+@item crf (@emph{crf})
+Set the quality for constant quality mode.
+
+@item crf_max (@emph{crf-max})
 In CRF mode, prevents VBV from lowering quality beyond this point.
-@item -qp @var{integer}
-Constant quantization parameter rate control method.
-@item -aq-mode @var{integer}
-AQ method
 
-Possible values:
+@item qp (@emph{qp})
+Set constant quantization rate control method parameter.
+
+@item aq-mode (@emph{aq-mode})
+Set AQ method. Possible values:
+
 @table @samp
-@item none
+@item none (@emph{0})
+Disabled.
 
-@item variance
+@item variance (@emph{1})
 Variance AQ (complexity mask).
-@item autovariance
+
+@item autovariance (@emph{2})
 Auto-variance AQ (experimental).
 @end table
-@item -aq-strength @var{float}
-AQ strength, reduces blocking and blurring in flat and textured areas.
-@item -psy @var{integer}
-Use psychovisual optimizations.
-@item -psy-rd @var{string}
-Strength of psychovisual optimization, in <psy-rd>:<psy-trellis> format.
-@item -rc-lookahead @var{integer}
-Number of frames to look ahead for frametype and ratecontrol.
-@item -weightb @var{integer}
-Weighted prediction for B-frames.
-@item -weightp @var{integer}
-Weighted prediction analysis method.
 
-Possible values:
-@table @samp
-@item none
+@item aq-strength (@emph{aq-strength})
+Set AQ strength, reduce blocking and blurring in flat and textured areas.
 
-@item simple
+@item psy
+Use psychovisual optimizations when set to 1. When set to 0, it has the
+same effect as @command{x264}'s @option{--no-psy} option.
 
-@item smart
+@item psy-rd  (@emph{psy-rd})
+Set strength of psychovisual optimization, in
+@var{psy-rd}:@var{psy-trellis} format.
 
-@end table
-@item -ssim @var{integer}
-Calculate and print SSIM stats.
-@item -intra-refresh @var{integer}
-Use Periodic Intra Refresh instead of IDR frames.
-@item -b-bias @var{integer}
-Influences how often B-frames are used.
-@item -b-pyramid @var{integer}
-Keep some B-frames as references.
+@item rc-lookahead (@emph{rc-lookahead})
+Set number of frames to look ahead for frametype and ratecontrol.
+
+@item weightb
+Enable weighted prediction for B-frames when set to 1. When set to 0,
+it has the same effect as @command{x264}'s @option{--no-weightb} option.
+
+@item weightp (@emph{weightp})
+Set weighted prediction method for P-frames. Possible values:
 
-Possible values:
 @table @samp
-@item none
+@item none (@emph{0})
+Disabled
+@item simple (@emph{1})
+Enable only weighted refs
+@item smart (@emph{2})
+Enable both weighted refs and duplicates
+@end table
 
-@item strict
+@item ssim (@emph{ssim})
+Enable calculation and printing SSIM stats after the encoding.
+
+@item intra-refresh (@emph{intra-refresh})
+Enable the use of Periodic Intra Refresh instead of IDR frames when set
+to 1.
+
+@item b-bias (@emph{b-bias})
+Set the influence on how often B-frames are used.
+
+@item b-pyramid (@emph{b-pyramid})
+Set method for keeping of some B-frames as references. Possible values:
+
+@table @samp
+@item none (@emph{none})
+Disabled.
+@item strict (@emph{strict})
 Strictly hierarchical pyramid.
-@item normal
+@item normal (@emph{normal})
 Non-strict (not Blu-ray compatible).
 @end table
-@item -mixed-refs @var{integer}
-One reference per partition, as opposed to one reference per macroblock.
-@item -8x8dct @var{integer}
-High profile 8x8 transform.
-@item -fast-pskip @var{integer}
-@item -aud @var{integer}
-Use access unit delimiters.
-@item -mbtree @var{integer}
-Use macroblock tree ratecontrol.
-@item -deblock @var{string}
-Loop filter parameters, in <alpha:beta> form.
-@item -cplxblur @var{float}
-Reduce fluctuations in QP (before curve compression).
-@item -partitions @var{string}
-A comma-separated list of partitions to consider, possible values: p8x8, p4x4, b8x8, i8x8, i4x4, none, all.
-@item -direct-pred @var{integer}
-Direct MV prediction mode
 
-Possible values:
-@table @samp
-@item none
+@item mixed-refs
+Enable the use of one reference per partition, as opposed to one
+reference per macroblock when set to 1. When set to 0, it has the
+same effect as @command{x264}'s @option{--no-mixed-refs} option.
 
-@item spatial
+@item 8x8dct
+Enable adaptive spatial transform (high profile 8x8 transform)
+when set to 1. When set to 0, it has the same effect as
+@command{x264}'s @option{--no-8x8dct} option.
 
-@item temporal
+@item fast-pskip
+Enable early SKIP detection on P-frames when set to 1. When set
+to 0, it has the same effect as @command{x264}'s
+@option{--no-fast-pskip} option.
 
-@item auto
+@item aud (@emph{aud})
+Enable use of access unit delimiters when set to 1.
+
+@item mbtree
+Enable use macroblock tree ratecontrol when set to 1. When set
+to 0, it has the same effect as @command{x264}'s
+@option{--no-mbtree} option.
 
+@item deblock (@emph{deblock})
+Set loop filter parameters, in @var{alpha}:@var{beta} form.
+
+@item cplxblur (@emph{cplxblur})
+Set fluctuations reduction in QP (before curve compression).
+
+@item partitions (@emph{partitions})
+Set partitions to consider as a comma-separated list of. Possible
+values in the list:
+
+@table @samp
+@item p8x8
+8x8 P-frame partition.
+@item p4x4
+4x4 P-frame partition.
+@item b8x8
+4x4 B-frame partition.
+@item i8x8
+8x8 I-frame partition.
+@item i4x4
+4x4 I-frame partition.
+(Enabling @samp{p4x4} requires @samp{p8x8} to be enabled. Enabling
+@samp{i8x8} requires adaptive spatial transform (@option{8x8dct}
+option) to be enabled.)
+@item none (@emph{none})
+Do not consider any partitions.
+@item all (@emph{all})
+Consider every partition.
 @end table
-@item -slice-max-size @var{integer}
-Limit the size of each slice in bytes.
-@item -stats @var{string}
-Filename for 2 pass stats.
-@item -nal-hrd @var{integer}
-Signal HRD information (requires vbv-bufsize; cbr not allowed in .mp4).
 
-Possible values:
+@item direct-pred (@emph{direct})
+Set direct MV prediction mode. Possible values:
+
 @table @samp
-@item none
+@item none (@emph{none})
+Disable MV prediction.
+@item spatial (@emph{spatial})
+Enable spatial predicting.
+@item temporal (@emph{temporal})
+Enable temporal predicting.
+@item auto (@emph{auto})
+Automatically decided.
+@end table
 
-@item vbr
+@item slice-max-size (@emph{slice-max-size})
+Set the limit of the size of each slice in bytes. If not specified
+but RTP payload size (@option{ps}) is specified, that is used.
 
-@item cbr
+@item stats (@emph{stats})
+Set the file name for multi-pass stats.
+
+@item nal-hrd (@emph{nal-hrd})
+Set signal HRD information (requires @option{vbv-bufsize} to be set).
+Possible values:
 
+@table @samp
+@item none (@emph{none})
+Disable HRD information signaling.
+@item vbr (@emph{vbr})
+Variable bit rate.
+@item cbr (@emph{cbr})
+Constant bit rate (not allowed in MP4 container).
 @end table
 
-@item x264opts @var{options}
-Allow to set any x264 option, see @code{x264 --fullhelp} for a list.
+@item x264opts (N.A.)
+Set any x264 option, see @command{x264 --fullhelp} for a list.
 
-@var{options} is a list of @var{key}=@var{value} couples separated by
+Argument is a list of @var{key}=@var{value} couples separated by
 ":". In @var{filter} and @var{psy-rd} options that use ":" as a separator
 themselves, use "," instead. They accept it as well since long ago but this
 is kept undocumented for some reason.
@@ -764,17 +1266,135 @@ For example to specify libx264 encoding options with @command{ffmpeg}:
 ffmpeg -i foo.mpg -vcodec libx264 -x264opts keyint=123:min-keyint=20 -an out.mkv
 @end example
 
-For more information about libx264 and the supported options see:
-@url{http://www.videolan.org/developers/x264.html}
+@item x264-params (N.A.)
+Override the x264 configuration using a :-separated list of key=value
+parameters.
+
+This option is functionally the same as the @option{x264opts}, but is
+duplicated for compability with the Libav fork.
 
-@item -x264-params @var{string}
-Override the x264 configuration using a :-separated list of key=value parameters.
+For example to specify libx264 encoding options with @command{ffmpeg}:
 @example
--x264-params level=30:bframes=0:weightp=0:cabac=0:ref=1:vbv-maxrate=768:vbv-bufsize=2000:analyse=all:me=umh:no-fast-pskip=1:subq=6:8x8dct=0:trellis=0
+ffmpeg -i INPUT -c:v libx264 -x264-params level=30:bframes=0:weightp=0:\
+cabac=0:ref=1:vbv-maxrate=768:vbv-bufsize=2000:analyse=all:me=umh:\
+no-fast-pskip=1:subq=6:8x8dct=0:trellis=0 OUTPUT
 @end example
 @end table
 
-Encoding avpresets for common usages are provided so they can be used with the
-general presets system (e.g. passing the @code{-pre} option).
+Encoding ffpresets for common usages are provided so they can be used with the
+general presets system (e.g. passing the @option{pre} option).
+
+@section libxvid
+
+Xvid MPEG-4 Part 2 encoder wrapper.
+
+This encoder requires the presence of the libxvidcore headers and library
+during configuration. You need to explicitly configure the build with
+@code{--enable-libxvid --enable-gpl}.
+
+The native @code{mpeg4} encoder supports the MPEG-4 Part 2 format, so
+users can encode to this format without this library.
+
+@subsection Options
+
+The following options are supported by the libxvid wrapper. Some of
+the following options are listed but are not documented, and
+correspond to shared codec options. See @ref{codec-options,,the Codec
+Options chapter} for their documentation. The other shared options
+which are not listed have no effect for the libxvid encoder.
+
+@table @option
+@item b
+
+@item g
+
+@item qmin
+
+@item qmax
+
+@item mpeg_quant
+
+@item threads
+
+@item bf
+
+@item b_qfactor
+
+@item b_qoffset
+
+@item flags
+Set specific encoding flags. Possible values:
+
+@table @samp
+
+@item mv4
+Use four motion vector by macroblock.
+
+@item aic
+Enable high quality AC prediction.
+
+@item gray
+Only encode grayscale.
+
+@item gmc
+Enable the use of global motion compensation (GMC).
+
+@item qpel
+Enable quarter-pixel motion compensation.
+
+@item cgop
+Enable closed GOP.
+
+@item global_header
+Place global headers in extradata instead of every keyframe.
+
+@end table
+
+@item trellis
+
+@item me_method
+Set motion estimation method. Possible values in decreasing order of
+speed and increasing order of quality:
+
+@table @samp
+@item zero
+Use no motion estimation (default).
+
+@item phods
+@item x1
+@item log
+Enable advanced diamond zonal search for 16x16 blocks and half-pixel
+refinement for 16x16 blocks. @samp{x1} and @samp{log} are aliases for
+@samp{phods}.
+
+@item epzs
+Enable all of the things described above, plus advanced diamond zonal
+search for 8x8 blocks, half-pixel refinement for 8x8 blocks, and motion
+estimation on chroma planes.
+
+@item full
+Enable all of the things described above, plus extended 16x16 and 8x8
+blocks search.
+@end table
+
+@item mbd
+Set macroblock decision algorithm. Possible values in the increasing
+order of quality:
+
+@table @samp
+@item simple
+Use macroblock comparing function algorithm (default).
+
+@item bits
+Enable rate distortion-based half pixel and quarter pixel refinement for
+16x16 blocks.
+
+@item rd
+Enable all of the things described above, plus rate distortion-based
+half pixel and quarter pixel refinement for 8x8 blocks, and rate
+distortion-based search using square pattern.
+@end table
+
+@end table
 
 @c man end VIDEO ENCODERS
diff --git a/lib/ffmpeg/doc/ffmpeg-codecs.texi b/lib/ffmpeg/doc/ffmpeg-codecs.texi
index db20aec..c53531d 100644
--- a/lib/ffmpeg/doc/ffmpeg-codecs.texi
+++ b/lib/ffmpeg/doc/ffmpeg-codecs.texi
@@ -17,6 +17,7 @@ the libavcodec library.
 
 @c man end DESCRIPTION
 
+@anchor{codec-options}
 @chapter Codec Options
 @c man begin CODEC OPTIONS
 
diff --git a/lib/ffmpeg/doc/ffmpeg-formats.texi b/lib/ffmpeg/doc/ffmpeg-formats.texi
index 30cf415..a8bc4ba 100644
--- a/lib/ffmpeg/doc/ffmpeg-formats.texi
+++ b/lib/ffmpeg/doc/ffmpeg-formats.texi
@@ -76,6 +76,9 @@ Enable RTP MP4A-LATM payload.
 Reduce the latency introduced by optional buffering
 @end table
 
+@item seek2any @var{integer} (@emph{input})
+Forces seeking to enable seek to any mode if set to 1. Default is 0.
+
 @item analyzeduration @var{integer} (@emph{input})
 Specify how many microseconds are analyzed to probe the input. A
 higher value will allow to detect more accurate information, but will
@@ -142,6 +145,12 @@ Use wallclock as timestamps.
 @item avoid_negative_ts @var{integer} (@emph{output})
 Shift timestamps to make them positive. 1 enables, 0 disables, default
 of -1 enables when required by target format.
+
+@item skip_initial_bytes @var{integer} (@emph{input})
+Set number initial bytes to skip. Default is 0.
+
+@item correct_ts_overflow @var{integer} (@emph{input})
+Correct single timestamp overflows if set to 1. Default is 1.
 @end table
 
 @c man end FORMAT OPTIONS
diff --git a/lib/ffmpeg/doc/filters.texi b/lib/ffmpeg/doc/filters.texi
index b170f85..cfce0f8 100644
--- a/lib/ffmpeg/doc/filters.texi
+++ b/lib/ffmpeg/doc/filters.texi
@@ -3,10 +3,10 @@
 
 Filtering in FFmpeg is enabled through the libavfilter library.
 
-In libavfilter, it is possible for filters to have multiple inputs and
-multiple outputs.
-To illustrate the sorts of things that are possible, we can
-use a complex filter graph. For example, the following one:
+In libavfilter, a filter can have multiple inputs and multiple
+outputs.
+To illustrate the sorts of things that are possible, we consider the
+following filtergraph.
 
 @example
 input --> split ---------------------> overlay --> output
@@ -15,25 +15,32 @@ input --> split ---------------------> overlay --> output
             +-----> crop --> vflip -------+
 @end example
 
-splits the stream in two streams, sends one stream through the crop filter
-and the vflip filter before merging it back with the other stream by
-overlaying it on top. You can use the following command to achieve this:
+This filtergraph splits the input stream in two streams, sends one
+stream through the crop filter and the vflip filter before merging it
+back with the other stream by overlaying it on top. You can use the
+following command to achieve this:
 
 @example
-ffmpeg -i input -vf "[in] split [T1], [T2] overlay=0:H/2 [out]; [T1] crop=iw:ih/2:0:ih/2, vflip [T2]" output
+ffmpeg -i INPUT -vf "split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2" OUTPUT
 @end example
 
 The result will be that in output the top half of the video is mirrored
 onto the bottom half.
 
-Filters are loaded using the @var{-vf} or @var{-af} option passed to
-@command{ffmpeg} or to @command{ffplay}. Filters in the same linear
-chain are separated by commas. In our example, @var{split,
-overlay} are in one linear chain, and @var{crop, vflip} are in
-another. The points where the linear chains join are labeled by names
-enclosed in square brackets. In our example, that is @var{[T1]} and
-@var{[T2]}. The special labels @var{[in]} and @var{[out]} are the points
-where video is input and output.
+Filters in the same linear chain are separated by commas, and distinct
+linear chains of filters are separated by semicolons. In our example,
+@var{crop,vflip} are in one linear chain, @var{split} and
+@var{overlay} are separately in another. The points where the linear
+chains join are labelled by names enclosed in square brackets. In the
+example, the split filter generates two outputs that are associated to
+the labels @var{[main]} and @var{[tmp]}.
+
+The stream sent to the second output of @var{split}, labelled as
+@var{[tmp]}, is processed through the @var{crop} filter, which crops
+away the lower half part of the video, and then vertically flipped. The
+@var{overlay} filter takes in input the first unchanged output of the
+split filter (which was labelled as @var{[main]}), and overlay on its
+lower half the output generated by the @var{crop,vflip} filterchain.
 
 Some filters take in input a list of parameters: they are specified
 after the filter name and an equal sign, and are separated from each other
@@ -2030,7 +2037,7 @@ This expression is evaluated only once during the filter
 configuration.
 
 @item h, out_h
-Set the crop area width. It defaults to @code{ih}.
+Set the crop area height. It defaults to @code{ih}.
 This expression is evaluated only once during the filter
 configuration.
 
diff --git a/lib/ffmpeg/doc/general.texi b/lib/ffmpeg/doc/general.texi
index 39b9360..086a280 100644
--- a/lib/ffmpeg/doc/general.texi
+++ b/lib/ffmpeg/doc/general.texi
@@ -24,7 +24,7 @@ instructions.  To enable using OpenJPEG in FFmpeg, pass @code{--enable-libopenjp
 @file{./configure}.
 
 
-@section OpenCORE and VisualOn libraries
+@section OpenCORE, VisualOn, and Fraunhofer libraries
 
 Spun off Google Android sources, OpenCore, VisualOn and Fraunhofer
 libraries provide encoders for a number of audio codecs.
@@ -32,9 +32,14 @@ libraries provide encoders for a number of audio codecs.
 @float NOTE
 OpenCORE and VisualOn libraries are under the Apache License 2.0
 (see @url{http://www.apache.org/licenses/LICENSE-2.0} for details), which is
-incompatible with the LGPL version 2.1 and GPL version 2. You have to
+incompatible to the LGPL version 2.1 and GPL version 2. You have to
 upgrade FFmpeg's license to LGPL version 3 (or if you have enabled
-GPL components, GPL version 3) to use it.
+GPL components, GPL version 3) by passing @code{--enable-version3} to configure in
+order to use it.
+
+The Fraunhofer AAC library is licensed under a license incompatible to the GPL
+and is not known to be compatible to the LGPL. Therefore, you have to pass
+@code{--enable-nonfree} to configure to use it.
 @end float
 
 @subsection OpenCORE AMR
diff --git a/lib/ffmpeg/doc/issue_tracker.txt b/lib/ffmpeg/doc/issue_tracker.txt
index d487f66..27b0009 100644
--- a/lib/ffmpeg/doc/issue_tracker.txt
+++ b/lib/ffmpeg/doc/issue_tracker.txt
@@ -24,7 +24,7 @@ a mail for every change to every issue.
 The subscription URL for the ffmpeg-trac list is:
 http(s)://ffmpeg.org/mailman/listinfo/ffmpeg-trac
 The URL of the webinterface of the tracker is:
-http(s)://ffmpeg.org/trac/ffmpeg
+http(s)://trac.ffmpeg.org
 
 Type:
 -----
diff --git a/lib/ffmpeg/doc/muxers.texi b/lib/ffmpeg/doc/muxers.texi
index 9d119c3..84dbdba 100644
--- a/lib/ffmpeg/doc/muxers.texi
+++ b/lib/ffmpeg/doc/muxers.texi
@@ -18,6 +18,23 @@ enabled muxers.
 
 A description of some of the currently available muxers follows.
 
+@anchor{aiff}
+@section aiff
+
+Audio Interchange File Format muxer.
+
+It accepts the following options:
+
+@table @option
+@item write_id3v2
+Enable ID3v2 tags writing when set to 1. Default is 0 (disabled).
+
+@item id3v2_version
+Select ID3v2 version to write. Currently only version 3 and 4 (aka.
+ID3v2.3 and ID3v2.4) are supported. The default is version 4.
+
+@end table
+
 @anchor{crc}
 @section crc
 
diff --git a/lib/ffmpeg/ffmpeg.c b/lib/ffmpeg/ffmpeg.c
index 2ea3694..b272b55 100644
--- a/lib/ffmpeg/ffmpeg.c
+++ b/lib/ffmpeg/ffmpeg.c
@@ -162,6 +162,8 @@ static struct termios oldtty;
 static int restore_tty;
 #endif
 
+static void free_input_threads(void);
+
 
 /* sub2video hack:
    Convert subtitles to video with alpha to insert them in filter graphs.
@@ -457,6 +459,9 @@ static void exit_program(void)
         av_freep(&output_streams[i]->logfile_prefix);
         av_freep(&output_streams[i]);
     }
+#if HAVE_PTHREADS
+    free_input_threads();
+#endif
     for (i = 0; i < nb_input_files; i++) {
         avformat_close_input(&input_files[i]->ctx);
         av_freep(&input_files[i]);
diff --git a/lib/ffmpeg/libavcodec/aaccoder.c b/lib/ffmpeg/libavcodec/aaccoder.c
index 994de28..45fbc2d 100644
--- a/lib/ffmpeg/libavcodec/aaccoder.c
+++ b/lib/ffmpeg/libavcodec/aaccoder.c
@@ -710,7 +710,7 @@ static void search_for_quantizers_twoloop(AVCodecContext *avctx,
                                           const float lambda)
 {
     int start = 0, i, w, w2, g;
-    int destbits = avctx->bit_rate * 1024.0 / avctx->sample_rate / avctx->channels;
+    int destbits = avctx->bit_rate * 1024.0 / avctx->sample_rate / avctx->channels * (lambda / 120.f);
     float dists[128] = { 0 }, uplims[128];
     float maxvals[128];
     int fflag, minscaler;
diff --git a/lib/ffmpeg/libavcodec/alacenc.c b/lib/ffmpeg/libavcodec/alacenc.c
index 4ee558c..83063ab 100644
--- a/lib/ffmpeg/libavcodec/alacenc.c
+++ b/lib/ffmpeg/libavcodec/alacenc.c
@@ -274,7 +274,7 @@ static void alac_linear_predictor(AlacEncodeContext *s, int ch)
         // generate warm-up samples
         residual[0] = samples[0];
         for (i = 1; i <= lpc.lpc_order; i++)
-            residual[i] = samples[i] - samples[i-1];
+            residual[i] = sign_extend(samples[i] - samples[i-1], s->write_sample_size);
 
         // perform lpc on remaining samples
         for (i = lpc.lpc_order + 1; i < s->frame_size; i++) {
diff --git a/lib/ffmpeg/libavcodec/atrac3.c b/lib/ffmpeg/libavcodec/atrac3.c
index 6216536..8475aa1 100644
--- a/lib/ffmpeg/libavcodec/atrac3.c
+++ b/lib/ffmpeg/libavcodec/atrac3.c
@@ -661,8 +661,8 @@ static int decode_channel_sound_unit(ATRAC3Context *q, GetBitContext *gb,
 
     snd->num_components = decode_tonal_components(gb, snd->components,
                                                   snd->bands_coded);
-    if (snd->num_components == -1)
-        return -1;
+    if (snd->num_components < 0)
+        return snd->num_components;
 
     num_subbands = decode_spectrum(gb, snd->spectrum);
 
diff --git a/lib/ffmpeg/libavcodec/cdgraphics.c b/lib/ffmpeg/libavcodec/cdgraphics.c
index 202211d..94ce6ae 100644
--- a/lib/ffmpeg/libavcodec/cdgraphics.c
+++ b/lib/ffmpeg/libavcodec/cdgraphics.c
@@ -300,7 +300,9 @@ static int cdg_decode_frame(AVCodecContext *avctx,
     inst    = bytestream_get_byte(&buf);
     inst    &= CDG_MASK;
     buf += 2;  /// skipping 2 unneeded bytes
-    bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);
+
+    if (buf_size > CDG_HEADER_SIZE)
+        bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);
 
     if ((command & CDG_MASK) == CDG_COMMAND) {
         switch (inst) {
diff --git a/lib/ffmpeg/libavcodec/dpxenc.c b/lib/ffmpeg/libavcodec/dpxenc.c
index bd44b16..f210bbc 100644
--- a/lib/ffmpeg/libavcodec/dpxenc.c
+++ b/lib/ffmpeg/libavcodec/dpxenc.c
@@ -212,6 +212,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     buf[803] = s->bits_per_component;
     write16(buf + 804, (s->bits_per_component == 10 || s->bits_per_component == 12) ?
                        1 : 0); /* packing method */
+    write32(buf + 808, HEADER_SIZE); /* data offset */
 
     /* Image source information header */
     write32(buf + 1628, avctx->sample_aspect_ratio.num);
diff --git a/lib/ffmpeg/libavcodec/dsputil.c b/lib/ffmpeg/libavcodec/dsputil.c
index 12cfb1b..02fd5b3 100644
--- a/lib/ffmpeg/libavcodec/dsputil.c
+++ b/lib/ffmpeg/libavcodec/dsputil.c
@@ -1897,7 +1897,7 @@ void ff_set_cmp(DSPContext* c, me_cmp_func *cmp, int type){
 
 static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
-    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
+    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
@@ -1922,7 +1922,7 @@ static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2,
         }
     }else
 #endif
-    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
+    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src1+i);
         long b = *(long*)(src2+i);
         *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
diff --git a/lib/ffmpeg/libavcodec/exr.c b/lib/ffmpeg/libavcodec/exr.c
index 1432817..d727791 100644
--- a/lib/ffmpeg/libavcodec/exr.c
+++ b/lib/ffmpeg/libavcodec/exr.c
@@ -348,7 +348,8 @@ static int decode_block(AVCodecContext *avctx, void *tdata,
     const uint8_t *src;
     int axmax = (avctx->width - (s->xmax + 1)) * 2 * s->desc->nb_components;
     int bxmin = s->xmin * 2 * s->desc->nb_components;
-    int ret, i, x, buf_size = s->buf_size;
+    int i, x, buf_size = s->buf_size;
+    int av_unused ret;
 
     line_offset = AV_RL64(s->table + jobnr * 8);
     // Check if the buffer has the required bytes needed from the offset
diff --git a/lib/ffmpeg/libavcodec/ffv1dec.c b/lib/ffmpeg/libavcodec/ffv1dec.c
index cb72203..2fa22a0 100644
--- a/lib/ffmpeg/libavcodec/ffv1dec.c
+++ b/lib/ffmpeg/libavcodec/ffv1dec.c
@@ -446,6 +446,10 @@ static int read_extra_header(FFV1Context *f)
     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);
 
     f->version = get_symbol(c, state, 0);
+    if (f->version < 2) {
+        av_log(f->avctx, AV_LOG_ERROR, "Invalid version in global header\n");
+        return AVERROR_INVALIDDATA;
+    }
     if (f->version > 2) {
         c->bytestream_end -= 4;
         f->minor_version = get_symbol(c, state, 0);
@@ -523,6 +527,7 @@ static int read_header(FFV1Context *f)
     memset(state, 128, sizeof(state));
 
     if (f->version < 2) {
+        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
         unsigned v= get_symbol(c, state, 0);
         if (v >= 2) {
             av_log(f->avctx, AV_LOG_ERROR, "invalid version %d in ver01 header\n", v);
@@ -535,15 +540,32 @@ static int read_header(FFV1Context *f)
                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
         }
 
-        f->colorspace = get_symbol(c, state, 0); //YUV cs type
+        colorspace     = get_symbol(c, state, 0); //YUV cs type
+        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
+        chroma_planes  = get_rac(c, state);
+        chroma_h_shift = get_symbol(c, state, 0);
+        chroma_v_shift = get_symbol(c, state, 0);
+        transparency   = get_rac(c, state);
+
+        if (f->plane_count) {
+            if (   colorspace    != f->colorspace
+                || bits_per_raw_sample != f->avctx->bits_per_raw_sample
+                || chroma_planes != f->chroma_planes
+                || chroma_h_shift!= f->chroma_h_shift
+                || chroma_v_shift!= f->chroma_v_shift
+                || transparency  != f->transparency) {
+                av_log(f->avctx, AV_LOG_ERROR, "Invalid change of global parameters\n");
+                return AVERROR_INVALIDDATA;
+            }
+        }
 
-        if (f->version > 0)
-            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);
+        f->colorspace     = colorspace;
+        f->avctx->bits_per_raw_sample = bits_per_raw_sample;
+        f->chroma_planes  = chroma_planes;
+        f->chroma_h_shift = chroma_h_shift;
+        f->chroma_v_shift = chroma_v_shift;
+        f->transparency   = transparency;
 
-        f->chroma_planes  = get_rac(c, state);
-        f->chroma_h_shift = get_symbol(c, state, 0);
-        f->chroma_v_shift = get_symbol(c, state, 0);
-        f->transparency   = get_rac(c, state);
         f->plane_count    = 2 + f->transparency;
     }
 
diff --git a/lib/ffmpeg/libavcodec/ffv1enc.c b/lib/ffmpeg/libavcodec/ffv1enc.c
index 70fcd65..1862636 100644
--- a/lib/ffmpeg/libavcodec/ffv1enc.c
+++ b/lib/ffmpeg/libavcodec/ffv1enc.c
@@ -274,7 +274,7 @@ static av_always_inline int encode_line(FFV1Context *s, int w,
     int run_mode  = 0;
 
     if (s->ac) {
-        if (c->bytestream_end - c->bytestream < w * 20) {
+        if (c->bytestream_end - c->bytestream < w * 35) {
             av_log(s->avctx, AV_LOG_ERROR, "encoded frame too large\n");
             return AVERROR_INVALIDDATA;
         }
diff --git a/lib/ffmpeg/libavcodec/flacdata.c b/lib/ffmpeg/libavcodec/flacdata.c
index 6fcbe39..1954f32 100644
--- a/lib/ffmpeg/libavcodec/flacdata.c
+++ b/lib/ffmpeg/libavcodec/flacdata.c
@@ -27,7 +27,7 @@ const int ff_flac_sample_rate_table[16] =
   8000, 16000, 22050, 24000, 32000, 44100, 48000, 96000,
   0, 0, 0, 0 };
 
-const int16_t ff_flac_blocksize_table[16] = {
+const int32_t ff_flac_blocksize_table[16] = {
      0,    192, 576<<0, 576<<1, 576<<2, 576<<3,      0,      0,
 256<<0, 256<<1, 256<<2, 256<<3, 256<<4, 256<<5, 256<<6, 256<<7
 };
diff --git a/lib/ffmpeg/libavcodec/flacdata.h b/lib/ffmpeg/libavcodec/flacdata.h
index 96a50b9..e2c1e5d 100644
--- a/lib/ffmpeg/libavcodec/flacdata.h
+++ b/lib/ffmpeg/libavcodec/flacdata.h
@@ -26,6 +26,6 @@
 
 extern const int ff_flac_sample_rate_table[16];
 
-extern const int16_t ff_flac_blocksize_table[16];
+extern const int32_t ff_flac_blocksize_table[16];
 
 #endif /* AVCODEC_FLACDATA_H */
diff --git a/lib/ffmpeg/libavcodec/flashsv.c b/lib/ffmpeg/libavcodec/flashsv.c
index 21464ed..4d13a5d 100644
--- a/lib/ffmpeg/libavcodec/flashsv.c
+++ b/lib/ffmpeg/libavcodec/flashsv.c
@@ -394,6 +394,10 @@ static int flashsv_decode_frame(AVCodecContext *avctx, void *data,
                     }
                     s->diff_start  = get_bits(&gb, 8);
                     s->diff_height = get_bits(&gb, 8);
+                    if (s->diff_start + s->diff_height > cur_blk_height) {
+                        av_log(avctx, AV_LOG_ERROR, "Block parameters invalid\n");
+                        return AVERROR_INVALIDDATA;
+                    }
                     av_log(avctx, AV_LOG_DEBUG,
                            "%dx%d diff start %d height %d\n",
                            i, j, s->diff_start, s->diff_height);
diff --git a/lib/ffmpeg/libavcodec/gifdec.c b/lib/ffmpeg/libavcodec/gifdec.c
index 8fb1f4b..727887a 100644
--- a/lib/ffmpeg/libavcodec/gifdec.c
+++ b/lib/ffmpeg/libavcodec/gifdec.c
@@ -462,6 +462,7 @@ static int gif_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, A
 
     if (s->keyframe) {
         s->keyframe_ok = 0;
+        s->gce_prev_disposal = GCE_DISPOSAL_NONE;
         if ((ret = gif_read_header1(s)) < 0)
             return ret;
 
diff --git a/lib/ffmpeg/libavcodec/h264.c b/lib/ffmpeg/libavcodec/h264.c
index 1cab49f..6513bb5 100644
--- a/lib/ffmpeg/libavcodec/h264.c
+++ b/lib/ffmpeg/libavcodec/h264.c
@@ -3778,6 +3778,7 @@ static int decode_slice_header(H264Context *h, H264Context *h0)
 
     if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];
     if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];
+    h->er.ref_count = h->ref_count[0];
 
     if (h->avctx->debug & FF_DEBUG_PICT_INFO) {
         av_log(h->avctx, AV_LOG_DEBUG,
@@ -4169,7 +4170,6 @@ static void er_add_slice(H264Context *h, int startx, int starty,
     if (CONFIG_ERROR_RESILIENCE) {
         ERContext *er = &h->er;
 
-        er->ref_count = h->ref_count[0];
         ff_er_add_slice(er, startx, starty, endx, endy, status);
     }
 }
diff --git a/lib/ffmpeg/libavcodec/h264_cavlc.c b/lib/ffmpeg/libavcodec/h264_cavlc.c
index b75e653..089d41a 100644
--- a/lib/ffmpeg/libavcodec/h264_cavlc.c
+++ b/lib/ffmpeg/libavcodec/h264_cavlc.c
@@ -706,7 +706,7 @@ int ff_h264_decode_mb_cavlc(H264Context *h){
                 down the code */
     if(h->slice_type_nos != AV_PICTURE_TYPE_I){
         if(h->mb_skip_run==-1)
-            h->mb_skip_run= get_ue_golomb(&h->gb);
+            h->mb_skip_run= get_ue_golomb_long(&h->gb);
 
         if (h->mb_skip_run--) {
             if(FRAME_MBAFF && (h->mb_y&1) == 0){
diff --git a/lib/ffmpeg/libavcodec/h264chroma.c b/lib/ffmpeg/libavcodec/h264chroma.c
index 3b780a0..8295f19 100644
--- a/lib/ffmpeg/libavcodec/h264chroma.c
+++ b/lib/ffmpeg/libavcodec/h264chroma.c
@@ -31,9 +31,11 @@
     c->put_h264_chroma_pixels_tab[0] = put_h264_chroma_mc8_ ## depth ## _c; \
     c->put_h264_chroma_pixels_tab[1] = put_h264_chroma_mc4_ ## depth ## _c; \
     c->put_h264_chroma_pixels_tab[2] = put_h264_chroma_mc2_ ## depth ## _c; \
+    c->put_h264_chroma_pixels_tab[3] = put_h264_chroma_mc1_ ## depth ## _c; \
     c->avg_h264_chroma_pixels_tab[0] = avg_h264_chroma_mc8_ ## depth ## _c; \
     c->avg_h264_chroma_pixels_tab[1] = avg_h264_chroma_mc4_ ## depth ## _c; \
     c->avg_h264_chroma_pixels_tab[2] = avg_h264_chroma_mc2_ ## depth ## _c; \
+    c->avg_h264_chroma_pixels_tab[3] = avg_h264_chroma_mc1_ ## depth ## _c; \
 
 void ff_h264chroma_init(H264ChromaContext *c, int bit_depth)
 {
diff --git a/lib/ffmpeg/libavcodec/h264chroma.h b/lib/ffmpeg/libavcodec/h264chroma.h
index 4e035b0..90a09cc 100644
--- a/lib/ffmpeg/libavcodec/h264chroma.h
+++ b/lib/ffmpeg/libavcodec/h264chroma.h
@@ -24,8 +24,8 @@
 typedef void (*h264_chroma_mc_func)(uint8_t *dst/*align 8*/, uint8_t *src/*align 1*/, int srcStride, int h, int x, int y);
 
 typedef struct H264ChromaContext {
-    h264_chroma_mc_func put_h264_chroma_pixels_tab[3];
-    h264_chroma_mc_func avg_h264_chroma_pixels_tab[3];
+    h264_chroma_mc_func put_h264_chroma_pixels_tab[4];
+    h264_chroma_mc_func avg_h264_chroma_pixels_tab[4];
 } H264ChromaContext;
 
 void ff_h264chroma_init(H264ChromaContext *c, int bit_depth);
diff --git a/lib/ffmpeg/libavcodec/h264chroma_template.c b/lib/ffmpeg/libavcodec/h264chroma_template.c
index 93559d7..b64172a 100644
--- a/lib/ffmpeg/libavcodec/h264chroma_template.c
+++ b/lib/ffmpeg/libavcodec/h264chroma_template.c
@@ -24,6 +24,34 @@
 #include "bit_depth_template.c"
 
 #define H264_CHROMA_MC(OPNAME, OP)\
+static void FUNCC(OPNAME ## h264_chroma_mc1)(uint8_t *_dst/*align 8*/, uint8_t *_src/*align 1*/, int stride, int h, int x, int y){\
+    pixel *dst = (pixel*)_dst;\
+    pixel *src = (pixel*)_src;\
+    const int A=(8-x)*(8-y);\
+    const int B=(  x)*(8-y);\
+    const int C=(8-x)*(  y);\
+    const int D=(  x)*(  y);\
+    int i;\
+    stride >>= sizeof(pixel)-1;\
+    \
+    av_assert2(x<8 && y<8 && x>=0 && y>=0);\
+\
+    if(D){\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
+    }else{\
+        const int E= B+C;\
+        const int step= C ? stride : 1;\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + E*src[step+0]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
+    }\
+}\
 static void FUNCC(OPNAME ## h264_chroma_mc2)(uint8_t *_dst/*align 8*/, uint8_t *_src/*align 1*/, int stride, int h, int x, int y){\
     pixel *dst = (pixel*)_dst;\
     pixel *src = (pixel*)_src;\
diff --git a/lib/ffmpeg/libavcodec/ivi_common.c b/lib/ffmpeg/libavcodec/ivi_common.c
index 21954ec..180c19e 100644
--- a/lib/ffmpeg/libavcodec/ivi_common.c
+++ b/lib/ffmpeg/libavcodec/ivi_common.c
@@ -804,8 +804,16 @@ static int decode_band(IVI45DecContext *ctx,
                 break;
 
             result = ivi_decode_blocks(&ctx->gb, band, tile, avctx);
-            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {
-                av_log(avctx, AV_LOG_ERROR, "Corrupted tile data encountered!\n");
+            if (result < 0) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Corrupted tile data encountered!\n");
+                break;
+            }
+
+            if (((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Tile data_size mismatch!\n");
+                result = AVERROR_INVALIDDATA;
                 break;
             }
 
diff --git a/lib/ffmpeg/libavcodec/j2kdec.c b/lib/ffmpeg/libavcodec/j2kdec.c
index 53c4f07..d086de7 100644
--- a/lib/ffmpeg/libavcodec/j2kdec.c
+++ b/lib/ffmpeg/libavcodec/j2kdec.c
@@ -31,6 +31,7 @@
 #include "bytestream.h"
 #include "internal.h"
 #include "j2k.h"
+#include "libavutil/avassert.h"
 #include "libavutil/common.h"
 
 #define JP2_SIG_TYPE    0x6A502020
@@ -302,6 +303,10 @@ static int get_cox(J2kDecoderContext *s, J2kCodingStyle *c)
      c->log2_cblk_width = bytestream2_get_byteu(&s->g) + 2; // cblk width
     c->log2_cblk_height = bytestream2_get_byteu(&s->g) + 2; // cblk height
 
+    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {
+        return AVERROR_PATCHWELCOME;
+    }
+
     c->cblk_style = bytestream2_get_byteu(&s->g);
     if (c->cblk_style != 0){ // cblk style
         av_log(s->avctx, AV_LOG_WARNING, "extra cblk styles %X\n", c->cblk_style);
@@ -719,6 +724,9 @@ static int decode_cblk(J2kDecoderContext *s, J2kCodingStyle *codsty, J2kT1Contex
     int bpass_csty_symbol = J2K_CBLK_BYPASS & codsty->cblk_style;
     int vert_causal_ctx_csty_symbol = J2K_CBLK_VSC & codsty->cblk_style;
 
+    av_assert0(width  <= J2K_MAX_CBLKW);
+    av_assert0(height <= J2K_MAX_CBLKH);
+
     for (y = 0; y < height+2; y++)
         memset(t1->flags[y], 0, (width+2)*sizeof(int));
 
diff --git a/lib/ffmpeg/libavcodec/kmvc.c b/lib/ffmpeg/libavcodec/kmvc.c
index ffef771..48cfff0 100644
--- a/lib/ffmpeg/libavcodec/kmvc.c
+++ b/lib/ffmpeg/libavcodec/kmvc.c
@@ -107,7 +107,7 @@ static int kmvc_decode_intra_8x8(KmvcContext * ctx, int w, int h)
                             val = bytestream2_get_byte(&ctx->g);
                             mx = val & 0xF;
                             my = val >> 4;
-                            if ((l0x-mx) + 320*(l0y-my) < 0 || (l0x-mx) + 320*(l0y-my) > 316*196) {
+                            if ((l0x-mx) + 320*(l0y-my) < 0 || (l0x-mx) + 320*(l0y-my) > 320*197 - 4) {
                                 av_log(ctx->avctx, AV_LOG_ERROR, "Invalid MV\n");
                                 return AVERROR_INVALIDDATA;
                             }
@@ -132,7 +132,7 @@ static int kmvc_decode_intra_8x8(KmvcContext * ctx, int w, int h)
                                     val = bytestream2_get_byte(&ctx->g);
                                     mx = val & 0xF;
                                     my = val >> 4;
-                                    if ((l1x-mx) + 320*(l1y-my) < 0 || (l1x-mx) + 320*(l1y-my) > 318*198) {
+                                    if ((l1x-mx) + 320*(l1y-my) < 0 || (l1x-mx) + 320*(l1y-my) > 320*199 - 2) {
                                         av_log(ctx->avctx, AV_LOG_ERROR, "Invalid MV\n");
                                         return AVERROR_INVALIDDATA;
                                     }
@@ -207,7 +207,7 @@ static int kmvc_decode_inter_8x8(KmvcContext * ctx, int w, int h)
                             val = bytestream2_get_byte(&ctx->g);
                             mx = (val & 0xF) - 8;
                             my = (val >> 4) - 8;
-                            if ((l0x+mx) + 320*(l0y+my) < 0 || (l0x+mx) + 320*(l0y+my) > 318*198) {
+                            if ((l0x+mx) + 320*(l0y+my) < 0 || (l0x+mx) + 320*(l0y+my) > 320*197 - 4) {
                                 av_log(ctx->avctx, AV_LOG_ERROR, "Invalid MV\n");
                                 return AVERROR_INVALIDDATA;
                             }
@@ -232,7 +232,7 @@ static int kmvc_decode_inter_8x8(KmvcContext * ctx, int w, int h)
                                     val = bytestream2_get_byte(&ctx->g);
                                     mx = (val & 0xF) - 8;
                                     my = (val >> 4) - 8;
-                                    if ((l1x+mx) + 320*(l1y+my) < 0 || (l1x+mx) + 320*(l1y+my) > 318*198) {
+                                    if ((l1x+mx) + 320*(l1y+my) < 0 || (l1x+mx) + 320*(l1y+my) > 320*199 - 2) {
                                         av_log(ctx->avctx, AV_LOG_ERROR, "Invalid MV\n");
                                         return AVERROR_INVALIDDATA;
                                     }
diff --git a/lib/ffmpeg/libavcodec/libx264.c b/lib/ffmpeg/libavcodec/libx264.c
index a394213..7e8fa65 100644
--- a/lib/ffmpeg/libavcodec/libx264.c
+++ b/lib/ffmpeg/libavcodec/libx264.c
@@ -175,7 +175,7 @@ static int X264_frame(AVCodecContext *ctx, AVPacket *pkt, const AVFrame *frame,
             frame->pict_type == AV_PICTURE_TYPE_P ? X264_TYPE_P :
             frame->pict_type == AV_PICTURE_TYPE_B ? X264_TYPE_B :
                                             X264_TYPE_AUTO;
-        if (x4->params.b_tff != frame->top_field_first) {
+        if (x4->params.b_interlaced && x4->params.b_tff != frame->top_field_first) {
             x4->params.b_tff = frame->top_field_first;
             x264_encoder_reconfig(x4->enc, &x4->params);
         }
diff --git a/lib/ffmpeg/libavcodec/mjpegdec.c b/lib/ffmpeg/libavcodec/mjpegdec.c
index 54090e5..d399efe 100644
--- a/lib/ffmpeg/libavcodec/mjpegdec.c
+++ b/lib/ffmpeg/libavcodec/mjpegdec.c
@@ -774,6 +774,12 @@ static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int p
     int resync_mb_y = 0;
     int resync_mb_x = 0;
 
+    if (s->nb_components != 3 && s->nb_components != 4)
+        return AVERROR_INVALIDDATA;
+    if (s->v_max != 1 || s->h_max != 1 || !s->lossless)
+        return AVERROR_INVALIDDATA;
+
+
     s->restart_count = s->restart_interval;
 
     av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,
@@ -1639,6 +1645,7 @@ int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
     MJpegDecodeContext *s = avctx->priv_data;
     const uint8_t *buf_end, *buf_ptr;
     const uint8_t *unescaped_buf_ptr;
+    int hshift, vshift;
     int unescaped_buf_size;
     int start_code;
     int i, index;
@@ -1817,6 +1824,9 @@ the_end:
     }
     if (s->upscale_v) {
         uint8_t *dst = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[(s->height - 1) * s->linesize[s->upscale_v]];
+        int w;
+        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);
+        w = s->width >> hshift;
         av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||
                    avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||
                    avctx->pix_fmt == AV_PIX_FMT_YUVJ422P ||
@@ -1825,16 +1835,16 @@ the_end:
             uint8_t *src1 = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[i / 2 * s->linesize[s->upscale_v]];
             uint8_t *src2 = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[(i + 1) / 2 * s->linesize[s->upscale_v]];
             if (src1 == src2) {
-                memcpy(dst, src1, s->width);
+                memcpy(dst, src1, w);
             } else {
-                for (index = 0; index < s->width; index++)
+                for (index = 0; index < w; index++)
                     dst[index] = (src1[index] + src2[index]) >> 1;
             }
             dst -= s->linesize[s->upscale_v];
         }
     }
     if (s->flipped && (s->avctx->flags & CODEC_FLAG_EMU_EDGE)) {
-        int hshift, vshift, j;
+        int j;
         avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);
         for (index=0; index<4; index++) {
             uint8_t *dst = s->picture_ptr->data[index];
diff --git a/lib/ffmpeg/libavcodec/mmvideo.c b/lib/ffmpeg/libavcodec/mmvideo.c
index c61cd57..b74424c 100644
--- a/lib/ffmpeg/libavcodec/mmvideo.c
+++ b/lib/ffmpeg/libavcodec/mmvideo.c
@@ -104,6 +104,9 @@ static int mm_decode_intra(MmContext * s, int half_horiz, int half_vert)
         if (half_horiz)
             run_length *=2;
 
+        if (run_length > s->avctx->width - x)
+            return AVERROR_INVALIDDATA;
+
         if (color) {
             memset(s->frame.data[0] + y*s->frame.linesize[0] + x, color, run_length);
             if (half_vert)
@@ -151,6 +154,8 @@ static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert)
             int replace_array = bytestream2_get_byte(&s->gb);
             for(j=0; j<8; j++) {
                 int replace = (replace_array >> (7-j)) & 1;
+                if (x + half_horiz >= s->avctx->width)
+                    return AVERROR_INVALIDDATA;
                 if (replace) {
                     int color = bytestream2_get_byte(&data_ptr);
                     s->frame.data[0][y*s->frame.linesize[0] + x] = color;
diff --git a/lib/ffmpeg/libavcodec/mpeg12.c b/lib/ffmpeg/libavcodec/mpeg12.c
index 0f94772..1da4b4d 100644
--- a/lib/ffmpeg/libavcodec/mpeg12.c
+++ b/lib/ffmpeg/libavcodec/mpeg12.c
@@ -1268,7 +1268,7 @@ static int mpeg_decode_postinit(AVCodecContext *avctx)
         s1->save_width           != s->width                ||
         s1->save_height          != s->height               ||
         s1->save_aspect_info     != s->aspect_ratio_info    ||
-        s1->save_progressive_seq != s->progressive_sequence ||
+        (s1->save_progressive_seq != s->progressive_sequence && (s->height&31)) ||
         0)
     {
 
@@ -2279,7 +2279,8 @@ static int decode_chunks(AVCodecContext *avctx,
         buf_ptr = avpriv_mpv_find_start_code(buf_ptr, buf_end, &start_code);
         if (start_code > 0x1ff) {
             if (s2->pict_type != AV_PICTURE_TYPE_B || avctx->skip_frame <= AVDISCARD_DEFAULT) {
-                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE)) {
+                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) &&
+                    !avctx->hwaccel) {
                     int i;
                     av_assert0(avctx->thread_count > 1);
 
@@ -2339,7 +2340,8 @@ static int decode_chunks(AVCodecContext *avctx,
                 s2->intra_dc_precision= 3;
                 s2->intra_matrix[0]= 1;
             }
-            if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) && s->slice_count) {
+            if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) &&
+                !avctx->hwaccel && s->slice_count) {
                 int i;
 
                 avctx->execute(avctx, slice_decode_thread,
@@ -2506,7 +2508,8 @@ static int decode_chunks(AVCodecContext *avctx,
                     break;
                 }
 
-                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE)) {
+                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) &&
+                    !avctx->hwaccel) {
                     int threshold = (s2->mb_height * s->slice_count +
                                      s2->slice_context_count / 2) /
                                     s2->slice_context_count;
diff --git a/lib/ffmpeg/libavcodec/mpegvideo.c b/lib/ffmpeg/libavcodec/mpegvideo.c
index 66a7ed5..3fbe03b 100644
--- a/lib/ffmpeg/libavcodec/mpegvideo.c
+++ b/lib/ffmpeg/libavcodec/mpegvideo.c
@@ -2102,7 +2102,7 @@ static inline int hpel_motion_lowres(MpegEncContext *s,
                                      int motion_x, int motion_y)
 {
     const int lowres   = s->avctx->lowres;
-    const int op_index = FFMIN(lowres, 2);
+    const int op_index = FFMIN(lowres, 3);
     const int s_mask   = (2 << lowres) - 1;
     int emu = 0;
     int sx, sy;
@@ -2155,7 +2155,7 @@ static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
     int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,
         uvsx, uvsy;
     const int lowres     = s->avctx->lowres;
-    const int op_index   = FFMIN(lowres-1+s->chroma_x_shift, 2);
+    const int op_index   = FFMIN(lowres-1+s->chroma_x_shift, 3);
     const int block_s    = 8>>lowres;
     const int s_mask     = (2 << lowres) - 1;
     const int h_edge_pos = s->h_edge_pos >> lowres;
@@ -2221,7 +2221,7 @@ static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
     ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
     ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
 
-    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) ||
+    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) || uvsrc_y<0 ||
         (unsigned) src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {
         s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,
                                 linesize >> field_based, 17, 17 + field_based,
@@ -2261,11 +2261,12 @@ static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
     pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);
 
     if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {
+        int hc = s->chroma_y_shift ? (h+1-bottom_field)>>1 : h;
         uvsx = (uvsx << 2) >> lowres;
         uvsy = (uvsy << 2) >> lowres;
-        if (h >> s->chroma_y_shift) {
-            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy);
-            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift, uvsx, uvsy);
+        if (hc) {
+            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, hc, uvsx, uvsy);
+            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, hc, uvsx, uvsy);
         }
     }
     // FIXME h261 lowres loop filter
@@ -2278,7 +2279,7 @@ static inline void chroma_4mv_motion_lowres(MpegEncContext *s,
                                             int mx, int my)
 {
     const int lowres     = s->avctx->lowres;
-    const int op_index   = FFMIN(lowres, 2);
+    const int op_index   = FFMIN(lowres, 3);
     const int block_s    = 8 >> lowres;
     const int s_mask     = (2 << lowres) - 1;
     const int h_edge_pos = s->h_edge_pos >> lowres + 1;
diff --git a/lib/ffmpeg/libavcodec/parser.c b/lib/ffmpeg/libavcodec/parser.c
index f7cb5cf..c30b43e 100644
--- a/lib/ffmpeg/libavcodec/parser.c
+++ b/lib/ffmpeg/libavcodec/parser.c
@@ -235,8 +235,10 @@ int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_s
     if(next == END_NOT_FOUND){
         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);
 
-        if(!new_buffer)
+        if(!new_buffer) {
+            pc->index = 0;
             return AVERROR(ENOMEM);
+        }
         pc->buffer = new_buffer;
         memcpy(&pc->buffer[pc->index], *buf, *buf_size);
         pc->index += *buf_size;
@@ -249,9 +251,11 @@ int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_s
     /* append to buffer */
     if(pc->index){
         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);
-
-        if(!new_buffer)
+        if(!new_buffer) {
+            pc->overread_index =
+            pc->index = 0;
             return AVERROR(ENOMEM);
+        }
         pc->buffer = new_buffer;
         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)
             memcpy(&pc->buffer[pc->index], *buf,
diff --git a/lib/ffmpeg/libavcodec/pngdsp.c b/lib/ffmpeg/libavcodec/pngdsp.c
index 1ee8b57..38ee458 100644
--- a/lib/ffmpeg/libavcodec/pngdsp.c
+++ b/lib/ffmpeg/libavcodec/pngdsp.c
@@ -30,7 +30,7 @@
 static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
 {
     long i;
-    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
+    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {
         long a = *(long *)(src1 + i);
         long b = *(long *)(src2 + i);
         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
diff --git a/lib/ffmpeg/libavcodec/pnm.c b/lib/ffmpeg/libavcodec/pnm.c
index 6d1eb6d..243b746 100644
--- a/lib/ffmpeg/libavcodec/pnm.c
+++ b/lib/ffmpeg/libavcodec/pnm.c
@@ -163,6 +163,8 @@ int ff_pnm_decode_header(AVCodecContext *avctx, PNMContext * const s)
         if (s->maxval >= 256) {
             if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) {
                 avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;
+                if (s->maxval != 65535)
+                    avctx->pix_fmt = AV_PIX_FMT_GRAY16;
             } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {
                 avctx->pix_fmt = AV_PIX_FMT_RGB48BE;
             } else if (avctx->pix_fmt == AV_PIX_FMT_YUV420P && s->maxval < 65536) {
diff --git a/lib/ffmpeg/libavcodec/qdm2.c b/lib/ffmpeg/libavcodec/qdm2.c
index 7136cf1..4c045eb 100644
--- a/lib/ffmpeg/libavcodec/qdm2.c
+++ b/lib/ffmpeg/libavcodec/qdm2.c
@@ -767,7 +767,8 @@ static int synthfilt_build_sb_samples (QDM2Context *q, GetBitContext *gb, int le
     int type34_first;
     float type34_div = 0;
     float type34_predictor;
-    float samples[10], sign_bits[16];
+    float samples[10];
+    int sign_bits[16] = {0};
 
     if (length == 0) {
         // If no data use noise
diff --git a/lib/ffmpeg/libavcodec/qtrle.c b/lib/ffmpeg/libavcodec/qtrle.c
index 1b92885..4c67067 100644
--- a/lib/ffmpeg/libavcodec/qtrle.c
+++ b/lib/ffmpeg/libavcodec/qtrle.c
@@ -67,7 +67,7 @@ static void qtrle_decode_1bpp(QtrleContext *s, int row_ptr, int lines_to_change)
      * line' at the beginning. Since we always interpret it as 'go to next line'
      * in the decoding loop (which makes code simpler/faster), the first line
      * would not be counted, so we count one more.
-     * See: https://ffmpeg.org/trac/ffmpeg/ticket/226
+     * See: https://trac.ffmpeg.org/ticket/226
      * In the following decoding loop, row_ptr will be the position of the
      * current row. */
 
diff --git a/lib/ffmpeg/libavcodec/rpza.c b/lib/ffmpeg/libavcodec/rpza.c
index a5da967..1e15e8f 100644
--- a/lib/ffmpeg/libavcodec/rpza.c
+++ b/lib/ffmpeg/libavcodec/rpza.c
@@ -84,7 +84,7 @@ static void rpza_decode_stream(RpzaContext *s)
     unsigned short *pixels = (unsigned short *)s->frame.data[0];
 
     int row_ptr = 0;
-    int pixel_ptr = 0;
+    int pixel_ptr = -4;
     int block_ptr;
     int pixel_x, pixel_y;
     int total_blocks;
@@ -140,6 +140,7 @@ static void rpza_decode_stream(RpzaContext *s)
             colorA = AV_RB16 (&s->buf[stream_ptr]);
             stream_ptr += 2;
             while (n_blocks--) {
+                ADVANCE_BLOCK()
                 block_ptr = row_ptr + pixel_ptr;
                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                     for (pixel_x = 0; pixel_x < 4; pixel_x++){
@@ -148,7 +149,6 @@ static void rpza_decode_stream(RpzaContext *s)
                     }
                     block_ptr += row_inc;
                 }
-                ADVANCE_BLOCK();
             }
             break;
 
@@ -187,6 +187,7 @@ static void rpza_decode_stream(RpzaContext *s)
             if (s->size - stream_ptr < n_blocks * 4)
                 return;
             while (n_blocks--) {
+                ADVANCE_BLOCK();
                 block_ptr = row_ptr + pixel_ptr;
                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                     index = s->buf[stream_ptr++];
@@ -197,7 +198,6 @@ static void rpza_decode_stream(RpzaContext *s)
                     }
                     block_ptr += row_inc;
                 }
-                ADVANCE_BLOCK();
             }
             break;
 
@@ -205,6 +205,7 @@ static void rpza_decode_stream(RpzaContext *s)
         case 0x00:
             if (s->size - stream_ptr < 16)
                 return;
+            ADVANCE_BLOCK();
             block_ptr = row_ptr + pixel_ptr;
             for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                 for (pixel_x = 0; pixel_x < 4; pixel_x++){
@@ -218,7 +219,6 @@ static void rpza_decode_stream(RpzaContext *s)
                 }
                 block_ptr += row_inc;
             }
-            ADVANCE_BLOCK();
             break;
 
         /* Unknown opcode */
diff --git a/lib/ffmpeg/libavcodec/sanm.c b/lib/ffmpeg/libavcodec/sanm.c
index caeaa36..61c3006 100644
--- a/lib/ffmpeg/libavcodec/sanm.c
+++ b/lib/ffmpeg/libavcodec/sanm.c
@@ -739,6 +739,11 @@ static int process_frame_obj(SANMVideoContext *ctx)
     w     = bytestream2_get_le16u(&ctx->gb);
     h     = bytestream2_get_le16u(&ctx->gb);
 
+    if (!w || !h) {
+        av_log(ctx->avctx, AV_LOG_ERROR, "dimensions are invalid\n");
+        return AVERROR_INVALIDDATA;
+    }
+
     if (ctx->width < left + w || ctx->height < top + h) {
         if (av_image_check_size(FFMAX(left + w, ctx->width),
                                 FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)
diff --git a/lib/ffmpeg/libavcodec/smacker.c b/lib/ffmpeg/libavcodec/smacker.c
index ad1d4c3..5143d0b 100644
--- a/lib/ffmpeg/libavcodec/smacker.c
+++ b/lib/ffmpeg/libavcodec/smacker.c
@@ -694,7 +694,7 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data,
                 }
                 val |= h[3].values[res] << 8;
                 pred[1] += sign_extend(val, 16);
-                *samples++ = av_clip_int16(pred[1]);
+                *samples++ = pred[1];
             } else {
                 if(vlc[0].table)
                     res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);
@@ -715,7 +715,7 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data,
                 }
                 val |= h[1].values[res] << 8;
                 pred[0] += sign_extend(val, 16);
-                *samples++ = av_clip_int16(pred[0]);
+                *samples++ = pred[0];
             }
         }
     } else { //8-bit data
diff --git a/lib/ffmpeg/libavcodec/srtdec.c b/lib/ffmpeg/libavcodec/srtdec.c
index 267561c..b16645a 100644
--- a/lib/ffmpeg/libavcodec/srtdec.c
+++ b/lib/ffmpeg/libavcodec/srtdec.c
@@ -204,7 +204,8 @@ static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                        "%*[ ]X1:%u X2:%u Y1:%u Y2:%u",
                        &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                        x1, x2, y1, y2);
-        buf += strcspn(buf, "\n") + 1;
+        buf += strcspn(buf, "\n");
+        buf += !!*buf;
         if (c >= 8) {
             *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
             *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
diff --git a/lib/ffmpeg/libavcodec/truemotion2.c b/lib/ffmpeg/libavcodec/truemotion2.c
index eacd728..18b38f8 100644
--- a/lib/ffmpeg/libavcodec/truemotion2.c
+++ b/lib/ffmpeg/libavcodec/truemotion2.c
@@ -948,14 +948,14 @@ static av_cold int decode_init(AVCodecContext *avctx)
     if (!l->Y1_base || !l->Y2_base || !l->U1_base ||
         !l->V1_base || !l->U2_base || !l->V2_base ||
         !l->last    || !l->clast) {
-        av_freep(l->Y1_base);
-        av_freep(l->Y2_base);
-        av_freep(l->U1_base);
-        av_freep(l->U2_base);
-        av_freep(l->V1_base);
-        av_freep(l->V2_base);
-        av_freep(l->last);
-        av_freep(l->clast);
+        av_freep(&l->Y1_base);
+        av_freep(&l->Y2_base);
+        av_freep(&l->U1_base);
+        av_freep(&l->U2_base);
+        av_freep(&l->V1_base);
+        av_freep(&l->V2_base);
+        av_freep(&l->last);
+        av_freep(&l->clast);
         return AVERROR(ENOMEM);
     }
     l->Y1 = l->Y1_base + l->y_stride  * 4 + 4;
diff --git a/lib/ffmpeg/libavcodec/utils.c b/lib/ffmpeg/libavcodec/utils.c
index 9aec72a..2fd61e6 100644
--- a/lib/ffmpeg/libavcodec/utils.c
+++ b/lib/ffmpeg/libavcodec/utils.c
@@ -474,7 +474,7 @@ static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
 
             buf->linesize[i] = picture.linesize[i];
 
-            buf->base[i] = av_malloc(size[i] + 16); //FIXME 16
+            buf->base[i] = av_malloc(size[i] + 16 + STRIDE_ALIGN - 1); //FIXME 16
             if (buf->base[i] == NULL)
                 return AVERROR(ENOMEM);
 
@@ -1938,7 +1938,7 @@ static int recode_subtitle(AVCodecContext *avctx,
         goto end;
     }
     outpkt->size -= outl;
-    outpkt->data[outpkt->size - 1] = '\0';
+    memset(outpkt->data + outpkt->size, 0, outl);
 
 end:
     if (cd != (iconv_t)-1)
diff --git a/lib/ffmpeg/libavcodec/vmdav.c b/lib/ffmpeg/libavcodec/vmdav.c
index d7f136c..79a33b8 100644
--- a/lib/ffmpeg/libavcodec/vmdav.c
+++ b/lib/ffmpeg/libavcodec/vmdav.c
@@ -162,7 +162,7 @@ static int rle_unpack(const unsigned char *src, int src_len, int src_count,
     const unsigned char *ps;
     const unsigned char *ps_end;
     unsigned char *pd;
-    int i, l;
+    int i, j, l;
     unsigned char *dest_end = dest + dest_len;
 
     ps = src;
@@ -188,9 +188,9 @@ static int rle_unpack(const unsigned char *src, int src_len, int src_count,
             ps += l;
             pd += l;
         } else {
-            if (dest_end - pd < i || ps_end - ps < 2)
+            if (dest_end - pd < 2*l || ps_end - ps < 2)
                 return ps - src;
-            for (i = 0; i < l; i++) {
+            for (j = 0; j < l; j++) {
                 *pd++ = ps[0];
                 *pd++ = ps[1];
             }
diff --git a/lib/ffmpeg/libavcodec/wmadec.c b/lib/ffmpeg/libavcodec/wmadec.c
index cdd2850..40a1040 100644
--- a/lib/ffmpeg/libavcodec/wmadec.c
+++ b/lib/ffmpeg/libavcodec/wmadec.c
@@ -506,6 +506,10 @@ static int wma_decode_block(WMACodecContext *s)
        coef escape coding */
     total_gain = 1;
     for(;;) {
+        if (get_bits_left(&s->gb) < 7) {
+            av_log(s->avctx, AV_LOG_ERROR, "total_gain overread\n");
+            return AVERROR_INVALIDDATA;
+        }
         a = get_bits(&s->gb, 7);
         total_gain += a;
         if (a != 127)
diff --git a/lib/ffmpeg/libavcodec/x86/dsputil_mmx.c b/lib/ffmpeg/libavcodec/x86/dsputil_mmx.c
index 15e46c7..ad1123c 100644
--- a/lib/ffmpeg/libavcodec/x86/dsputil_mmx.c
+++ b/lib/ffmpeg/libavcodec/x86/dsputil_mmx.c
@@ -1764,7 +1764,7 @@ static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,
     const int high_bit_depth = bit_depth > 8;
 
 #if HAVE_SSE2_INLINE
-    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {
+    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX && avctx->lowres == 0) {
         c->idct_put              = ff_idct_xvid_sse2_put;
         c->idct_add              = ff_idct_xvid_sse2_add;
         c->idct                  = ff_idct_xvid_sse2;
diff --git a/lib/ffmpeg/libavcodec/x86/mathops.h b/lib/ffmpeg/libavcodec/x86/mathops.h
index 79e29e6..76ea131 100644
--- a/lib/ffmpeg/libavcodec/x86/mathops.h
+++ b/lib/ffmpeg/libavcodec/x86/mathops.h
@@ -74,7 +74,7 @@ static av_always_inline av_const int64_t MUL64(int a, int b)
 static inline av_const int mid_pred(int a, int b, int c)
 {
     int i=b;
-    __asm__ volatile(
+    __asm__ (
         "cmp    %2, %1 \n\t"
         "cmovg  %1, %0 \n\t"
         "cmovg  %2, %1 \n\t"
diff --git a/lib/ffmpeg/libavcodec/x86/mpegvideo.c b/lib/ffmpeg/libavcodec/x86/mpegvideo.c
index 903ad62..8007fb5 100644
--- a/lib/ffmpeg/libavcodec/x86/mpegvideo.c
+++ b/lib/ffmpeg/libavcodec/x86/mpegvideo.c
@@ -26,7 +26,7 @@
 #include "libavcodec/mpegvideo.h"
 #include "dsputil_mmx.h"
 
-#if HAVE_INLINE_ASM
+#if HAVE_MMX_INLINE
 
 static void dct_unquantize_h263_intra_mmx(MpegEncContext *s,
                                   int16_t *block, int n, int qscale)
@@ -574,11 +574,11 @@ static void  denoise_dct_sse2(MpegEncContext *s, int16_t *block){
     );
 }
 
-#endif /* HAVE_INLINE_ASM */
+#endif /* HAVE_MMX_INLINE */
 
 av_cold void ff_MPV_common_init_x86(MpegEncContext *s)
 {
-#if HAVE_INLINE_ASM
+#if HAVE_MMX_INLINE
     int mm_flags = av_get_cpu_flags();
 
     if (mm_flags & AV_CPU_FLAG_MMX) {
@@ -596,5 +596,5 @@ av_cold void ff_MPV_common_init_x86(MpegEncContext *s)
                 s->denoise_dct= denoise_dct_mmx;
         }
     }
-#endif /* HAVE_INLINE_ASM */
+#endif /* HAVE_MMX_INLINE */
 }
diff --git a/lib/ffmpeg/libavcodec/x86/vp3dsp_init.c b/lib/ffmpeg/libavcodec/x86/vp3dsp_init.c
index 288dbcc..75dcdf6 100644
--- a/lib/ffmpeg/libavcodec/x86/vp3dsp_init.c
+++ b/lib/ffmpeg/libavcodec/x86/vp3dsp_init.c
@@ -43,7 +43,7 @@ void ff_vp3_v_loop_filter_mmxext(uint8_t *src, int stride,
 void ff_vp3_h_loop_filter_mmxext(uint8_t *src, int stride,
                                  int *bounding_values);
 
-#if HAVE_INLINE_ASM
+#if HAVE_MMX_INLINE
 
 #define MOVQ_BFE(regd)                                  \
     __asm__ volatile (                                  \
@@ -95,15 +95,15 @@ static void put_vp_no_rnd_pixels8_l2_mmx(uint8_t *dst, const uint8_t *a, const u
         :"memory");
 //    STOP_TIMER("put_vp_no_rnd_pixels8_l2_mmx")
 }
-#endif /* HAVE_INLINE_ASM */
+#endif /* HAVE_MMX_INLINE */
 
 av_cold void ff_vp3dsp_init_x86(VP3DSPContext *c, int flags)
 {
     int cpuflags = av_get_cpu_flags();
 
-#if HAVE_INLINE_ASM
+#if HAVE_MMX_INLINE
     c->put_no_rnd_pixels_l2 = put_vp_no_rnd_pixels8_l2_mmx;
-#endif /* HAVE_INLINE_ASM */
+#endif /* HAVE_MMX_INLINE */
 
 #if ARCH_X86_32
     if (EXTERNAL_MMX(cpuflags)) {
diff --git a/lib/ffmpeg/libavcodec/xbmdec.c b/lib/ffmpeg/libavcodec/xbmdec.c
index 8632db7..04318f1 100644
--- a/lib/ffmpeg/libavcodec/xbmdec.c
+++ b/lib/ffmpeg/libavcodec/xbmdec.c
@@ -59,7 +59,7 @@ static int xbm_decode_frame(AVCodecContext *avctx, void *data,
         int number, len;
 
         ptr += strcspn(ptr, "#");
-        if (sscanf(ptr, "#define %256s %u", name, &number) != 2) {
+        if (sscanf(ptr, "#define %255s %u", name, &number) != 2) {
             av_log(avctx, AV_LOG_ERROR, "Unexpected preprocessor directive\n");
             return AVERROR_INVALIDDATA;
         }
diff --git a/lib/ffmpeg/libavdevice/v4l2.c b/lib/ffmpeg/libavdevice/v4l2.c
index 6726b0b..049f0bd 100644
--- a/lib/ffmpeg/libavdevice/v4l2.c
+++ b/lib/ffmpeg/libavdevice/v4l2.c
@@ -985,6 +985,9 @@ static int v4l2_read_header(AVFormatContext *s1)
     if (codec_id == AV_CODEC_ID_RAWVIDEO)
         st->codec->codec_tag =
             avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
+    else if (codec_id == AV_CODEC_ID_H264) {
+        st->need_parsing = AVSTREAM_PARSE_HEADERS;
+    }
     if (desired_format == V4L2_PIX_FMT_YVU420)
         st->codec->codec_tag = MKTAG('Y', 'V', '1', '2');
     else if (desired_format == V4L2_PIX_FMT_YVU410)
diff --git a/lib/ffmpeg/libavdevice/x11grab.c b/lib/ffmpeg/libavdevice/x11grab.c
index 6124006..7db1da6 100644
--- a/lib/ffmpeg/libavdevice/x11grab.c
+++ b/lib/ffmpeg/libavdevice/x11grab.c
@@ -78,6 +78,7 @@ struct x11grab {
     int  show_region;        /**< set by a private option. */
     char *framerate;         /**< Set by a private option. */
 
+    Cursor c;
     Window region_win;       /**< This is used by show_region option. */
 };
 
@@ -353,7 +354,6 @@ paint_mouse_pointer(XImage *image, struct x11grab *s)
      * Anyone who performs further investigation of the xlib API likely risks
      * permanent brain damage. */
     uint8_t *pix = image->data;
-    Cursor c;
     Window w;
     XSetWindowAttributes attr;
 
@@ -361,9 +361,10 @@ paint_mouse_pointer(XImage *image, struct x11grab *s)
     if (image->bits_per_pixel != 24 && image->bits_per_pixel != 32)
         return;
 
-    c = XCreateFontCursor(dpy, XC_left_ptr);
+    if(!s->c)
+        s->c = XCreateFontCursor(dpy, XC_left_ptr);
     w = DefaultRootWindow(dpy);
-    attr.cursor = c;
+    attr.cursor = s->c;
     XChangeWindowAttributes(dpy, w, CWCursor, &attr);
 
     xcim = XFixesGetCursorImage(dpy);
diff --git a/lib/ffmpeg/libavfilter/af_earwax.c b/lib/ffmpeg/libavfilter/af_earwax.c
index a169d2a..8216b14 100644
--- a/lib/ffmpeg/libavfilter/af_earwax.c
+++ b/lib/ffmpeg/libavfilter/af_earwax.c
@@ -117,6 +117,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *insamples)
         ff_get_audio_buffer(inlink, AV_PERM_WRITE,
                                   insamples->audio->nb_samples);
     int ret;
+    int len;
 
     if (!outsamples)
         return AVERROR(ENOMEM);
@@ -126,16 +127,20 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *insamples)
     out   = (int16_t *)outsamples->data[0];
     in    = (int16_t *)insamples ->data[0];
 
+    len = FFMIN(NUMTAPS, 2*insamples->audio->nb_samples);
     // copy part of new input and process with saved input
-    memcpy(taps+NUMTAPS, in, NUMTAPS * sizeof(*taps));
-    out   = scalarproduct(taps, taps + NUMTAPS, out);
+    memcpy(taps+NUMTAPS, in, len * sizeof(*taps));
+    out   = scalarproduct(taps, taps + len, out);
 
     // process current input
-    endin = in + insamples->audio->nb_samples * 2 - NUMTAPS;
-    scalarproduct(in, endin, out);
-
-    // save part of input for next round
-    memcpy(taps, endin, NUMTAPS * sizeof(*taps));
+    if (2*insamples->audio->nb_samples >= NUMTAPS ){
+        endin = in + insamples->audio->nb_samples * 2 - NUMTAPS;
+        scalarproduct(in, endin, out);
+
+        // save part of input for next round
+        memcpy(taps, endin, NUMTAPS * sizeof(*taps));
+    } else
+        memmove(taps, taps + 2*insamples->audio->nb_samples, NUMTAPS * sizeof(*taps));
 
     ret = ff_filter_frame(outlink, outsamples);
     avfilter_unref_buffer(insamples);
diff --git a/lib/ffmpeg/libavfilter/src_movie.c b/lib/ffmpeg/libavfilter/src_movie.c
index bd45766..ec9131e 100644
--- a/lib/ffmpeg/libavfilter/src_movie.c
+++ b/lib/ffmpeg/libavfilter/src_movie.c
@@ -91,13 +91,13 @@ static int movie_request_frame(AVFilterLink *outlink);
 static AVStream *find_stream(void *log, AVFormatContext *avf, const char *spec)
 {
     int i, ret, already = 0, stream_id = -1;
-    char type_char, dummy;
+    char type_char[2], dummy;
     AVStream *found = NULL;
     enum AVMediaType type;
 
-    ret = sscanf(spec, "d%[av]%d%c", &type_char, &stream_id, &dummy);
+    ret = sscanf(spec, "d%1[av]%d%c", type_char, &stream_id, &dummy);
     if (ret >= 1 && ret <= 2) {
-        type = type_char == 'v' ? AVMEDIA_TYPE_VIDEO : AVMEDIA_TYPE_AUDIO;
+        type = type_char[0] == 'v' ? AVMEDIA_TYPE_VIDEO : AVMEDIA_TYPE_AUDIO;
         ret = av_find_best_stream(avf, type, stream_id, -1, NULL, 0);
         if (ret < 0) {
             av_log(log, AV_LOG_ERROR, "No %s stream with index '%d' found\n",
diff --git a/lib/ffmpeg/libavfilter/vf_boxblur.c b/lib/ffmpeg/libavfilter/vf_boxblur.c
index a4ac50a..25c9f7d 100644
--- a/lib/ffmpeg/libavfilter/vf_boxblur.c
+++ b/lib/ffmpeg/libavfilter/vf_boxblur.c
@@ -346,13 +346,13 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)
     }
     avfilter_copy_buffer_ref_props(out, in);
 
-    for (plane = 0; in->data[plane] && plane < 4; plane++)
+    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
         hblur(out->data[plane], out->linesize[plane],
               in ->data[plane], in ->linesize[plane],
               w[plane], h[plane], boxblur->radius[plane], boxblur->power[plane],
               boxblur->temp);
 
-    for (plane = 0; in->data[plane] && plane < 4; plane++)
+    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
         vblur(out->data[plane], out->linesize[plane],
               out->data[plane], out->linesize[plane],
               w[plane], h[plane], boxblur->radius[plane], boxblur->power[plane],
diff --git a/lib/ffmpeg/libavfilter/vf_delogo.c b/lib/ffmpeg/libavfilter/vf_delogo.c
index bf0ac62..ed5423e 100644
--- a/lib/ffmpeg/libavfilter/vf_delogo.c
+++ b/lib/ffmpeg/libavfilter/vf_delogo.c
@@ -232,7 +232,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)
         avfilter_copy_buffer_ref_props(out, in);
     }
 
-    for (plane = 0; plane < 4 && in->data[plane]; plane++) {
+    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
         int hsub = plane == 1 || plane == 2 ? hsub0 : 0;
         int vsub = plane == 1 || plane == 2 ? vsub0 : 0;
 
diff --git a/lib/ffmpeg/libavfilter/vf_fieldorder.c b/lib/ffmpeg/libavfilter/vf_fieldorder.c
index 06e0369..e2dfefe 100644
--- a/lib/ffmpeg/libavfilter/vf_fieldorder.c
+++ b/lib/ffmpeg/libavfilter/vf_fieldorder.c
@@ -137,7 +137,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *frame)
             "picture will move %s one line\n",
             s->dst_tff ? "up" : "down");
     h = frame->video->h;
-    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
+    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {
         line_step = frame->linesize[plane];
         line_size = s->line_size[plane];
         data = frame->data[plane];
diff --git a/lib/ffmpeg/libavfilter/vf_fps.c b/lib/ffmpeg/libavfilter/vf_fps.c
index 29eedc7..d55b5dc 100644
--- a/lib/ffmpeg/libavfilter/vf_fps.c
+++ b/lib/ffmpeg/libavfilter/vf_fps.c
@@ -203,7 +203,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *buf)
     }
 
     /* now wait for the next timestamp */
-    if (buf->pts == AV_NOPTS_VALUE) {
+    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {
         return write_to_fifo(s->fifo, buf);
     }
 
diff --git a/lib/ffmpeg/libavfilter/vf_gradfun.c b/lib/ffmpeg/libavfilter/vf_gradfun.c
index 13154f0..e488232 100644
--- a/lib/ffmpeg/libavfilter/vf_gradfun.c
+++ b/lib/ffmpeg/libavfilter/vf_gradfun.c
@@ -216,7 +216,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)
         avfilter_copy_buffer_ref_props(out, in);
     }
 
-    for (p = 0; p < 4 && in->data[p]; p++) {
+    for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {
         int w = inlink->w;
         int h = inlink->h;
         int r = gf->radius;
diff --git a/lib/ffmpeg/libavfilter/vf_hflip.c b/lib/ffmpeg/libavfilter/vf_hflip.c
index c3b92c2..fc88fe2 100644
--- a/lib/ffmpeg/libavfilter/vf_hflip.c
+++ b/lib/ffmpeg/libavfilter/vf_hflip.c
@@ -90,7 +90,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)
     if (av_pix_fmt_desc_get(inlink->format)->flags & PIX_FMT_PAL)
         memcpy(out->data[1], in->data[1], AVPALETTE_SIZE);
 
-    for (plane = 0; plane < 4 && in->data[plane]; plane++) {
+    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
         step = flip->max_step[plane];
         hsub = (plane == 1 || plane == 2) ? flip->hsub : 0;
         vsub = (plane == 1 || plane == 2) ? flip->vsub : 0;
diff --git a/lib/ffmpeg/libavfilter/vf_kerndeint.c b/lib/ffmpeg/libavfilter/vf_kerndeint.c
index 9b77e09..b694027 100644
--- a/lib/ffmpeg/libavfilter/vf_kerndeint.c
+++ b/lib/ffmpeg/libavfilter/vf_kerndeint.c
@@ -162,7 +162,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *inpic)
     avfilter_copy_buffer_ref_props(outpic, inpic);
     outpic->video->interlaced = 0;
 
-    for (plane = 0; inpic->data[plane] && plane < 4; plane++) {
+    for (plane = 0; plane < 4 && inpic->data[plane] && inpic->linesize[plane]; plane++) {
         h = plane == 0 ? inlink->h : inlink->h >> kerndeint->vsub;
         bwidth = kerndeint->tmp_bwidth[plane];
 
diff --git a/lib/ffmpeg/libavfilter/vf_lut.c b/lib/ffmpeg/libavfilter/vf_lut.c
index bdfe712..350f4af 100644
--- a/lib/ffmpeg/libavfilter/vf_lut.c
+++ b/lib/ffmpeg/libavfilter/vf_lut.c
@@ -298,7 +298,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)
         }
     } else {
         /* planar */
-        for (plane = 0; plane < 4 && in->data[plane]; plane++) {
+        for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
             int vsub = plane == 1 || plane == 2 ? lut->vsub : 0;
             int hsub = plane == 1 || plane == 2 ? lut->hsub : 0;
 
diff --git a/lib/ffmpeg/libavfilter/vf_pad.c b/lib/ffmpeg/libavfilter/vf_pad.c
index 5c146f2..a4f99c8 100644
--- a/lib/ffmpeg/libavfilter/vf_pad.c
+++ b/lib/ffmpeg/libavfilter/vf_pad.c
@@ -254,7 +254,7 @@ static AVFilterBufferRef *get_video_buffer(AVFilterLink *inlink, int perms, int
     picref->video->w = w;
     picref->video->h = h;
 
-    for (plane = 0; plane < 4 && picref->data[plane]; plane++)
+    for (plane = 0; plane < 4 && picref->data[plane] && picref->linesize[plane]; plane++)
         picref->data[plane] += FFALIGN(pad->x >> pad->draw.hsub[plane], align) * pad->draw.pixelstep[plane] +
                                       (pad->y >> pad->draw.vsub[plane])        * picref->linesize[plane];
 
diff --git a/lib/ffmpeg/libavfilter/vf_showinfo.c b/lib/ffmpeg/libavfilter/vf_showinfo.c
index f91721d..402f6bf 100644
--- a/lib/ffmpeg/libavfilter/vf_showinfo.c
+++ b/lib/ffmpeg/libavfilter/vf_showinfo.c
@@ -50,7 +50,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *frame)
     uint32_t plane_checksum[4] = {0}, checksum = 0;
     int i, plane, vsub = desc->log2_chroma_h;
 
-    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
+    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {
         int64_t linesize = av_image_get_linesize(frame->format, frame->video->w, plane);
         uint8_t *data = frame->data[plane];
         int h = plane == 1 || plane == 2 ? inlink->h >> vsub : inlink->h;
@@ -80,7 +80,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *frame)
            av_get_picture_type_char(frame->video->pict_type),
            checksum, plane_checksum[0]);
 
-    for (plane = 1; plane < 4 && frame->data[plane]; plane++)
+    for (plane = 1; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)
         av_log(ctx, AV_LOG_INFO, " %08X", plane_checksum[plane]);
     av_log(ctx, AV_LOG_INFO, "]\n");
 
diff --git a/lib/ffmpeg/libavfilter/vf_subtitles.c b/lib/ffmpeg/libavfilter/vf_subtitles.c
index 7513e24..7ba883a 100644
--- a/lib/ffmpeg/libavfilter/vf_subtitles.c
+++ b/lib/ffmpeg/libavfilter/vf_subtitles.c
@@ -332,7 +332,7 @@ static av_cold int init_subtitles(AVFilterContext *ctx, const char *args)
     pkt.size = 0;
     while (av_read_frame(fmt, &pkt) >= 0) {
         int i, got_subtitle;
-        AVSubtitle sub;
+        AVSubtitle sub = {0};
 
         if (pkt.stream_index == sid) {
             ret = avcodec_decode_subtitle2(dec_ctx, &sub, &got_subtitle, &pkt);
diff --git a/lib/ffmpeg/libavformat/aiffdec.c b/lib/ffmpeg/libavformat/aiffdec.c
index 8d466fa..4a26298 100644
--- a/lib/ffmpeg/libavformat/aiffdec.c
+++ b/lib/ffmpeg/libavformat/aiffdec.c
@@ -192,7 +192,7 @@ static int aiff_probe(AVProbeData *p)
 static int aiff_read_header(AVFormatContext *s)
 {
     int ret, size, filesize;
-    int64_t offset = 0;
+    int64_t offset = 0, position;
     uint32_t tag;
     unsigned version = AIFF_C_VERSION1;
     AVIOContext *pb = s->pb;
@@ -236,6 +236,7 @@ static int aiff_read_header(AVFormatContext *s)
                 goto got_sound;
             break;
         case MKTAG('I', 'D', '3', ' '):
+            position = avio_tell(pb);
             ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
             if (id3v2_extra_meta)
                 if ((ret = ff_id3v2_parse_apic(s, &id3v2_extra_meta)) < 0) {
@@ -243,6 +244,8 @@ static int aiff_read_header(AVFormatContext *s)
                     return ret;
                 }
             ff_id3v2_free_extra_meta(&id3v2_extra_meta);
+            if (position + size > avio_tell(pb))
+                avio_skip(pb, position + size - avio_tell(pb));
             break;
         case MKTAG('F', 'V', 'E', 'R'):     /* Version chunk */
             version = avio_rb32(pb);
diff --git a/lib/ffmpeg/libavformat/avidec.c b/lib/ffmpeg/libavformat/avidec.c
index 00ac3de..4852e44 100644
--- a/lib/ffmpeg/libavformat/avidec.c
+++ b/lib/ffmpeg/libavformat/avidec.c
@@ -706,7 +706,9 @@ static int avi_read_header(AVFormatContext *s)
             }
             break;
         case MKTAG('s', 't', 'r', 'd'):
-            if (stream_index >= (unsigned)s->nb_streams || s->streams[stream_index]->codec->extradata_size) {
+            if (stream_index >= (unsigned)s->nb_streams
+                || s->streams[stream_index]->codec->extradata_size
+                || s->streams[stream_index]->codec->codec_tag == MKTAG('H','2','6','4')) {
                 avio_skip(pb, size);
             } else {
                 uint64_t cur_pos = avio_tell(pb);
@@ -1003,9 +1005,9 @@ start_sync:
                || st->discard >= AVDISCARD_ALL){
                 if (!exit_early) {
                     ast->frame_offset += get_duration(ast, size);
+                    avio_skip(pb, size);
+                    goto start_sync;
                 }
-                avio_skip(pb, size);
-                goto start_sync;
             }
 
             if (d[2] == 'p' && d[3] == 'c' && size<=4*256+4) {
@@ -1301,7 +1303,7 @@ static int avi_read_idx1(AVFormatContext *s, int size)
         st = s->streams[index];
         ast = st->priv_data;
 
-        if(first_packet && first_packet_pos && len) {
+        if (first_packet && first_packet_pos) {
             data_offset = first_packet_pos - pos;
             first_packet = 0;
         }
diff --git a/lib/ffmpeg/libavformat/avienc.c b/lib/ffmpeg/libavformat/avienc.c
index 15f0794..918992f 100644
--- a/lib/ffmpeg/libavformat/avienc.c
+++ b/lib/ffmpeg/libavformat/avienc.c
@@ -523,7 +523,7 @@ static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)
     int size= pkt->size;
 
     av_dlog(s, "dts:%s packet_count:%d stream_index:%d\n", av_ts2str(pkt->dts), avist->packet_count, stream_index);
-    while(enc->block_align==0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > avist->packet_count && enc->codec_id != AV_CODEC_ID_XSUB){
+    while(enc->block_align==0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > avist->packet_count && enc->codec_id != AV_CODEC_ID_XSUB && avist->packet_count){
         AVPacket empty_packet;
 
         if(pkt->dts - avist->packet_count > 60000){
diff --git a/lib/ffmpeg/libavformat/dtsdec.c b/lib/ffmpeg/libavformat/dtsdec.c
index 5c05758..009dd5c 100644
--- a/lib/ffmpeg/libavformat/dtsdec.c
+++ b/lib/ffmpeg/libavformat/dtsdec.c
@@ -34,6 +34,7 @@ static int dts_probe(AVProbeData *p)
     uint32_t state = -1;
     int markers[3] = {0};
     int sum, max;
+    int64_t diff = 0;
 
     buf = p->buf;
 
@@ -54,12 +55,16 @@ static int dts_probe(AVProbeData *p)
         if (state == DCA_MARKER_14B_LE)
             if ((bytestream_get_be16(&bufp) & 0xF0FF) == 0xF007)
                 markers[2]++;
+
+        if (buf - p->buf >= 4)
+            diff += FFABS(AV_RL16(buf) - AV_RL16(buf-4));
     }
     sum = markers[0] + markers[1] + markers[2];
     max = markers[1] > markers[0];
     max = markers[2] > markers[max] ? 2 : max;
     if (markers[max] > 3 && p->buf_size / markers[max] < 32*1024 &&
-        markers[max] * 4 > sum * 3)
+        markers[max] * 4 > sum * 3 &&
+        diff / p->buf_size > 200)
         return AVPROBE_SCORE_MAX/2+1;
 
     return 0;
diff --git a/lib/ffmpeg/libavformat/flvenc.c b/lib/ffmpeg/libavformat/flvenc.c
index 502da0f..e1dd43f 100644
--- a/lib/ffmpeg/libavformat/flvenc.c
+++ b/lib/ffmpeg/libavformat/flvenc.c
@@ -493,10 +493,13 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
                 return ret;
     } else if (enc->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
                (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
+        if (!s->streams[pkt->stream_index]->nb_frames) {
         av_log(s, AV_LOG_ERROR, "Malformed AAC bitstream detected: "
                "use audio bitstream filter 'aac_adtstoasc' to fix it "
                "('-bsf:a aac_adtstoasc' option with ffmpeg)\n");
         return AVERROR_INVALIDDATA;
+        }
+        av_log(s, AV_LOG_WARNING, "aac bitstream error\n");
     }
 
     if (flv->delay == AV_NOPTS_VALUE)
diff --git a/lib/ffmpeg/libavformat/idcin.c b/lib/ffmpeg/libavformat/idcin.c
index c32607d..e73e873 100644
--- a/lib/ffmpeg/libavformat/idcin.c
+++ b/lib/ffmpeg/libavformat/idcin.c
@@ -93,7 +93,7 @@ typedef struct IdcinDemuxContext {
 
 static int idcin_probe(AVProbeData *p)
 {
-    unsigned int number;
+    unsigned int number, sample_rate;
 
     /*
      * This is what you could call a "probabilistic" file check: id CIN
@@ -122,18 +122,18 @@ static int idcin_probe(AVProbeData *p)
        return 0;
 
     /* check the audio sample rate */
-    number = AV_RL32(&p->buf[8]);
-    if ((number != 0) && ((number < 8000) | (number > 48000)))
+    sample_rate = AV_RL32(&p->buf[8]);
+    if (sample_rate && (sample_rate < 8000 || sample_rate > 48000))
         return 0;
 
     /* check the audio bytes/sample */
     number = AV_RL32(&p->buf[12]);
-    if (number > 2)
+    if (number > 2 || sample_rate && !number)
         return 0;
 
     /* check the audio channels */
     number = AV_RL32(&p->buf[16]);
-    if (number > 2)
+    if (number > 2 || sample_rate && !number)
         return 0;
 
     /* return half certainly since this check is a bit sketchy */
diff --git a/lib/ffmpeg/libavformat/iff.c b/lib/ffmpeg/libavformat/iff.c
index 100d981..17be2b1 100644
--- a/lib/ffmpeg/libavformat/iff.c
+++ b/lib/ffmpeg/libavformat/iff.c
@@ -478,5 +478,5 @@ AVInputFormat ff_iff_demuxer = {
     .read_probe     = iff_probe,
     .read_header    = iff_read_header,
     .read_packet    = iff_read_packet,
-    .flags          = AVFMT_GENERIC_INDEX,
+    .flags          = AVFMT_GENERIC_INDEX | AVFMT_NO_BYTE_SEEK,
 };
diff --git a/lib/ffmpeg/libavformat/jacosubdec.c b/lib/ffmpeg/libavformat/jacosubdec.c
index 89e7e1b..c622dd0 100644
--- a/lib/ffmpeg/libavformat/jacosubdec.c
+++ b/lib/ffmpeg/libavformat/jacosubdec.c
@@ -63,7 +63,7 @@ static int jacosub_probe(AVProbeData *p)
                 return AVPROBE_SCORE_MAX/2 + 1;
             return 0;
         }
-        ptr += strcspn(ptr, "\n") + 1;
+        ptr += ff_subtitles_next_line(ptr);
     }
     return 0;
 }
diff --git a/lib/ffmpeg/libavformat/libmodplug.c b/lib/ffmpeg/libavformat/libmodplug.c
index aa8edcc..4ba9392 100644
--- a/lib/ffmpeg/libavformat/libmodplug.c
+++ b/lib/ffmpeg/libavformat/libmodplug.c
@@ -347,6 +347,19 @@ static int modplug_read_seek(AVFormatContext *s, int stream_idx, int64_t ts, int
     return 0;
 }
 
+static const char modplug_extensions[] = "669,abc,amf,ams,dbm,dmf,dsm,far,it,mdl,med,mid,mod,mt2,mtm,okt,psm,ptm,s3m,stm,ult,umx,xm,itgz,itr,itz,mdgz,mdr,mdz,s3gz,s3r,s3z,xmgz,xmr,xmz";
+
+static int modplug_probe(AVProbeData *p)
+{
+    if (av_match_ext(p->filename, modplug_extensions)) {
+        if (p->buf_size < 16384)
+            return AVPROBE_SCORE_MAX/4-1;
+        else
+            return AVPROBE_SCORE_MAX/2;
+    }
+    return 0;
+}
+
 static const AVClass modplug_class = {
     .class_name = "ModPlug demuxer",
     .item_name  = av_default_item_name,
@@ -358,11 +371,11 @@ AVInputFormat ff_libmodplug_demuxer = {
     .name           = "libmodplug",
     .long_name      = NULL_IF_CONFIG_SMALL("ModPlug demuxer"),
     .priv_data_size = sizeof(ModPlugContext),
+    .read_probe     = modplug_probe,
     .read_header    = modplug_read_header,
     .read_packet    = modplug_read_packet,
     .read_close     = modplug_read_close,
     .read_seek      = modplug_read_seek,
-    .extensions     = "669,abc,amf,ams,dbm,dmf,dsm,far,it,mdl,med,mid,mod,mt2,mtm,okt,psm,ptm,s3m,stm,ult,umx,xm"
-                      ",itgz,itr,itz,mdgz,mdr,mdz,s3gz,s3r,s3z,xmgz,xmr,xmz", // compressed mods
+    .extensions     = modplug_extensions,
     .priv_class     = &modplug_class,
 };
diff --git a/lib/ffmpeg/libavformat/lxfdec.c b/lib/ffmpeg/libavformat/lxfdec.c
index 90c4974..9925739 100644
--- a/lib/ffmpeg/libavformat/lxfdec.c
+++ b/lib/ffmpeg/libavformat/lxfdec.c
@@ -258,6 +258,7 @@ static int lxf_read_header(AVFormatContext *s)
     st->codec->bit_rate   = 1000000 * ((video_params >> 14) & 0xFF);
     st->codec->codec_tag  = video_params & 0xF;
     st->codec->codec_id   = ff_codec_get_id(lxf_tags, st->codec->codec_tag);
+    st->need_parsing      = AVSTREAM_PARSE_HEADERS;
 
     av_log(s, AV_LOG_DEBUG, "record: %x = %i-%02i-%02i\n",
            record_date, 1900 + (record_date & 0x7F), (record_date >> 7) & 0xF,
diff --git a/lib/ffmpeg/libavformat/matroskadec.c b/lib/ffmpeg/libavformat/matroskadec.c
index 4d243ca..2718e0a 100644
--- a/lib/ffmpeg/libavformat/matroskadec.c
+++ b/lib/ffmpeg/libavformat/matroskadec.c
@@ -1689,8 +1689,10 @@ static int matroska_read_header(AVFormatContext *s)
             avio_wl16(&b, 1);
             avio_wl16(&b, track->audio.channels);
             avio_wl16(&b, track->audio.bitdepth);
+            if (track->audio.out_samplerate < 0 || track->audio.out_samplerate > INT_MAX)
+                return AVERROR_INVALIDDATA;
             avio_wl32(&b, track->audio.out_samplerate);
-            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);
+            avio_wl32(&b, av_rescale((matroska->duration * matroska->time_scale), track->audio.out_samplerate, AV_TIME_BASE * 1000));
         } else if (codec_id == AV_CODEC_ID_RV10 || codec_id == AV_CODEC_ID_RV20 ||
                    codec_id == AV_CODEC_ID_RV30 || codec_id == AV_CODEC_ID_RV40) {
             extradata_offset = 26;
@@ -1916,10 +1918,10 @@ static void matroska_clear_queue(MatroskaDemuxContext *matroska)
 }
 
 static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,
-                                int size, int type,
+                                int* buf_size, int type,
                                 uint32_t **lace_buf, int *laces)
 {
-    int res = 0, n;
+    int res = 0, n, size = *buf_size;
     uint8_t *data = *buf;
     uint32_t *lace_size;
 
@@ -2017,6 +2019,7 @@ static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,
 
     *buf      = data;
     *lace_buf = lace_size;
+    *buf_size = size;
 
     return res;
 }
@@ -2204,6 +2207,7 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data,
     uint32_t *lace_size = NULL;
     int n, flags, laces = 0;
     uint64_t num;
+    int trust_default_duration = 1;
 
     if ((n = matroska_ebmlnum_uint(matroska, data, size, &num)) < 0) {
         av_log(matroska->ctx, AV_LOG_ERROR, "EBML block data error\n");
@@ -2252,13 +2256,21 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data,
             matroska->skip_to_keyframe = 0;
     }
 
-    res = matroska_parse_laces(matroska, &data, size, (flags & 0x06) >> 1,
+    res = matroska_parse_laces(matroska, &data, &size, (flags & 0x06) >> 1,
                                &lace_size, &laces);
 
     if (res)
         goto end;
 
-    if (!block_duration)
+    if (track->audio.samplerate == 8000) {
+        // If this is needed for more codecs, then add them here
+        if (st->codec->codec_id == AV_CODEC_ID_AC3) {
+            if(track->audio.samplerate != st->codec->sample_rate || !st->codec->frame_size)
+                trust_default_duration = 0;
+        }
+    }
+
+    if (!block_duration && trust_default_duration)
         block_duration = track->default_duration * laces / matroska->time_scale;
 
     if (cluster_time != (uint64_t)-1 && (block_time >= 0 || cluster_time >= -block_time))
@@ -2359,7 +2371,6 @@ static int matroska_parse_cluster_incremental(MatroskaDemuxContext *matroska)
         }
     }
 
-    if (res < 0)  matroska->done = 1;
     return res;
 }
 
@@ -2444,10 +2455,11 @@ static int matroska_read_seek(AVFormatContext *s, int stream_index,
         if (tracks[i].type == MATROSKA_TRACK_TYPE_SUBTITLE
             && tracks[i].stream->discard != AVDISCARD_ALL) {
             index_sub = av_index_search_timestamp(tracks[i].stream, st->index_entries[index].timestamp, AVSEEK_FLAG_BACKWARD);
-            if (index_sub >= 0
-                && st->index_entries[index_sub].pos < st->index_entries[index_min].pos
-                && st->index_entries[index].timestamp - st->index_entries[index_sub].timestamp < 30000000000/matroska->time_scale)
-                index_min = index_sub;
+            while(index_sub >= 0
+                  && index_min >= 0
+                  && tracks[i].stream->index_entries[index_sub].pos < st->index_entries[index_min].pos
+                  && st->index_entries[index].timestamp - tracks[i].stream->index_entries[index_sub].timestamp < 30000000000/matroska->time_scale)
+                index_min--;
         }
     }
 
diff --git a/lib/ffmpeg/libavformat/matroskaenc.c b/lib/ffmpeg/libavformat/matroskaenc.c
index 4544f8e..c506835 100644
--- a/lib/ffmpeg/libavformat/matroskaenc.c
+++ b/lib/ffmpeg/libavformat/matroskaenc.c
@@ -27,6 +27,7 @@
 #include "avc.h"
 #include "flacenc.h"
 #include "avlanguage.h"
+#include "subtitles.h"
 #include "libavutil/samplefmt.h"
 #include "libavutil/sha.h"
 #include "libavutil/intreadwrite.h"
@@ -816,6 +817,17 @@ static int mkv_write_tag(AVFormatContext *s, AVDictionary *m, unsigned int eleme
     return 0;
 }
 
+static int mkv_check_tag(AVDictionary *m)
+{
+    AVDictionaryEntry *t = NULL;
+
+    while ((t = av_dict_get(m, "", t, AV_DICT_IGNORE_SUFFIX)))
+        if (av_strcasecmp(t->key, "title") && av_strcasecmp(t->key, "stereo_mode"))
+            return 1;
+
+    return 0;
+}
+
 static int mkv_write_tags(AVFormatContext *s)
 {
     ebml_master tags = {0};
@@ -823,7 +835,7 @@ static int mkv_write_tags(AVFormatContext *s)
 
     ff_metadata_conv_ctx(s, ff_mkv_metadata_conv, NULL);
 
-    if (av_dict_get(s->metadata, "", NULL, AV_DICT_IGNORE_SUFFIX)) {
+    if (mkv_check_tag(s->metadata)) {
         ret = mkv_write_tag(s, s->metadata, 0, 0, &tags);
         if (ret < 0) return ret;
     }
@@ -831,7 +843,7 @@ static int mkv_write_tags(AVFormatContext *s)
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
 
-        if (!av_dict_get(st->metadata, "", 0, AV_DICT_IGNORE_SUFFIX))
+        if (!mkv_check_tag(st->metadata))
             continue;
 
         ret = mkv_write_tag(s, st->metadata, MATROSKA_ID_TAGTARGETS_TRACKUID, i + 1, &tags);
@@ -841,7 +853,7 @@ static int mkv_write_tags(AVFormatContext *s)
     for (i = 0; i < s->nb_chapters; i++) {
         AVChapter *ch = s->chapters[i];
 
-        if (!av_dict_get(ch->metadata, "", NULL, AV_DICT_IGNORE_SUFFIX))
+        if (!mkv_check_tag(ch->metadata))
             continue;
 
         ret = mkv_write_tag(s, ch->metadata, MATROSKA_ID_TAGTARGETS_CHAPTERUID, ch->id, &tags);
@@ -1168,7 +1180,7 @@ static int srt_get_duration(uint8_t **buf)
             s_hsec += 1000*s_sec;       e_hsec += 1000*e_sec;
             duration = e_hsec - s_hsec;
         }
-        *buf += strcspn(*buf, "\n") + 1;
+        *buf += ff_subtitles_next_line(*buf);
     }
     return duration;
 }
@@ -1403,7 +1415,6 @@ const AVCodecTag additional_audio_tags[] = {
 };
 
 const AVCodecTag additional_video_tags[] = {
-    { AV_CODEC_ID_PRORES,    0xFFFFFFFF },
     { AV_CODEC_ID_RV10,      0xFFFFFFFF },
     { AV_CODEC_ID_RV20,      0xFFFFFFFF },
     { AV_CODEC_ID_RV30,      0xFFFFFFFF },
diff --git a/lib/ffmpeg/libavformat/microdvddec.c b/lib/ffmpeg/libavformat/microdvddec.c
index 4b42846..5d9b13e 100644
--- a/lib/ffmpeg/libavformat/microdvddec.c
+++ b/lib/ffmpeg/libavformat/microdvddec.c
@@ -47,7 +47,7 @@ static int microdvd_probe(AVProbeData *p)
             sscanf(ptr, "{%*d}{%*d}%c",  &c) != 1 &&
             sscanf(ptr, "{DEFAULT}{}%c", &c) != 1)
             return 0;
-        ptr += strcspn(ptr, "\n") + 1;
+        ptr += ff_subtitles_next_line(ptr);
     }
     return AVPROBE_SCORE_MAX;
 }
diff --git a/lib/ffmpeg/libavformat/mmsh.c b/lib/ffmpeg/libavformat/mmsh.c
index 86a0575..d5d2f0c 100644
--- a/lib/ffmpeg/libavformat/mmsh.c
+++ b/lib/ffmpeg/libavformat/mmsh.c
@@ -309,14 +309,16 @@ static int mmsh_open_internal(URLContext *h, const char *uri, int flags, int tim
     return 0;
 fail:
     av_freep(&stream_selection);
-    mmsh_close(h);
     av_dlog(NULL, "Connection failed with error %d\n", err);
     return err;
 }
 
 static int mmsh_open(URLContext *h, const char *uri, int flags)
 {
-    return mmsh_open_internal(h, uri, flags, 0, 0);
+    int ret = mmsh_open_internal(h, uri, flags, 0, 0);
+    if (ret < 0)
+        mmsh_close(h);
+    return ret;
 }
 
 static int handle_chunk_type(MMSHContext *mmsh)
diff --git a/lib/ffmpeg/libavformat/mov.c b/lib/ffmpeg/libavformat/mov.c
index bf90ec8..533c8d2 100644
--- a/lib/ffmpeg/libavformat/mov.c
+++ b/lib/ffmpeg/libavformat/mov.c
@@ -880,7 +880,7 @@ static int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */
     // set the AVCodecContext duration because the duration of individual tracks
     // may be inaccurate
-    if (c->time_scale > 0)
+    if (c->time_scale > 0 && !c->trex_data)
         c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);
     avio_rb32(pb); /* preferred scale */
 
diff --git a/lib/ffmpeg/libavformat/movenc.c b/lib/ffmpeg/libavformat/movenc.c
index 42496b5..dd7dd52 100644
--- a/lib/ffmpeg/libavformat/movenc.c
+++ b/lib/ffmpeg/libavformat/movenc.c
@@ -3173,6 +3173,14 @@ int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
         memcpy(trk->vos_data, enc->extradata, trk->vos_len);
     }
 
+    if (enc->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
+        (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
+        if (!s->streams[pkt->stream_index]->nb_frames) {
+            av_log(s, AV_LOG_ERROR, "malformated aac bitstream, use -absf aac_adtstoasc\n");
+            return -1;
+        }
+        av_log(s, AV_LOG_WARNING, "aac bitstream error\n");
+    }
     if (enc->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1) {
         /* from x264 or from bytestream h264 */
         /* nal reformating needed */
@@ -3183,10 +3191,6 @@ int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
         } else {
             size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);
         }
-    } else if (enc->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
-               (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
-        av_log(s, AV_LOG_ERROR, "malformated aac bitstream, use -absf aac_adtstoasc\n");
-        return -1;
     } else {
         avio_write(pb, pkt->data, size);
     }
@@ -3644,6 +3648,9 @@ static int mov_write_header(AVFormatContext *s)
             }else{
                 track->sample_size = (av_get_bits_per_sample(st->codec->codec_id) >> 3) * st->codec->channels;
             }
+            if (st->codec->codec_id == AV_CODEC_ID_ILBC) {
+                track->audio_vbr = 1;
+            }
             if (track->mode != MODE_MOV &&
                 track->enc->codec_id == AV_CODEC_ID_MP3 && track->timescale < 16000) {
                 av_log(s, AV_LOG_ERROR, "track %d: muxing mp3 at %dhz is not supported\n",
diff --git a/lib/ffmpeg/libavformat/mp3dec.c b/lib/ffmpeg/libavformat/mp3dec.c
index 57e4ba3..858e93c 100644
--- a/lib/ffmpeg/libavformat/mp3dec.c
+++ b/lib/ffmpeg/libavformat/mp3dec.c
@@ -37,9 +37,11 @@
 
 typedef struct {
     int64_t filesize;
+    int64_t header_filesize;
     int xing_toc;
     int start_pad;
     int end_pad;
+    int is_cbr;
 } MP3Context;
 
 /* mp3 read */
@@ -185,6 +187,9 @@ static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)
     if (size && frames && !is_cbr)
         st->codec->bit_rate = av_rescale(size, 8 * c.sample_rate, frames * (int64_t)spf);
 
+    mp3->is_cbr          = is_cbr;
+    mp3->header_filesize = size;
+
     return 0;
 }
 
@@ -274,21 +279,33 @@ static int mp3_seek(AVFormatContext *s, int stream_index, int64_t timestamp,
                     int flags)
 {
     MP3Context *mp3 = s->priv_data;
-    AVIndexEntry *ie;
+    AVIndexEntry *ie, ie1;
     AVStream *st = s->streams[0];
     int64_t ret  = av_index_search_timestamp(st, timestamp, flags);
     int i, j;
 
-    if (!mp3->xing_toc) {
+    if (mp3->is_cbr && st->duration > 0 && mp3->header_filesize > s->data_offset) {
+        int64_t filesize = avio_size(s->pb);
+        int64_t duration;
+        if (filesize <= s->data_offset)
+            filesize = mp3->header_filesize;
+        filesize -= s->data_offset;
+        duration = av_rescale(st->duration, filesize, mp3->header_filesize - s->data_offset);
+        ie = &ie1;
+        timestamp = av_clip64(timestamp, 0, duration);
+        ie->timestamp = timestamp;
+        ie->pos       = av_rescale(timestamp, filesize, duration) + s->data_offset;
+    } else if (mp3->xing_toc) {
+        if (ret < 0)
+            return ret;
+
+        ie = &st->index_entries[ret];
+    } else {
         st->skip_samples = timestamp <= 0 ? mp3->start_pad + 528 + 1 : 0;
 
         return -1;
     }
 
-    if (ret < 0)
-        return ret;
-
-    ie = &st->index_entries[ret];
     ret = avio_seek(s->pb, ie->pos, SEEK_SET);
     if (ret < 0)
         return ret;
diff --git a/lib/ffmpeg/libavformat/mpeg.c b/lib/ffmpeg/libavformat/mpeg.c
index 4eaffd8..82957a1 100644
--- a/lib/ffmpeg/libavformat/mpeg.c
+++ b/lib/ffmpeg/libavformat/mpeg.c
@@ -649,6 +649,7 @@ static int vobsub_read_header(AVFormatContext *s)
             st->id = stream_id;
             st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;
             st->codec->codec_id   = AV_CODEC_ID_DVD_SUBTITLE;
+            avpriv_set_pts_info(st, 64, 1, 1000);
             av_dict_set(&st->metadata, "language", id, 0);
             av_log(s, AV_LOG_DEBUG, "IDX stream[%d] id=%s\n", stream_id, id);
             header_parsed = 1;
@@ -806,6 +807,21 @@ static int vobsub_read_seek(AVFormatContext *s, int stream_index,
                             int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
 {
     MpegDemuxContext *vobsub = s->priv_data;
+
+    /* Rescale requested timestamps based on the first stream (timebase is the
+     * same for all subtitles stream within a .idx/.sub). Rescaling is done just
+     * like in avformat_seek_file(). */
+    if (stream_index == -1 && s->nb_streams != 1) {
+        AVRational time_base = s->streams[0]->time_base;
+        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);
+        min_ts = av_rescale_rnd(min_ts, time_base.den,
+                                time_base.num * (int64_t)AV_TIME_BASE,
+                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);
+        max_ts = av_rescale_rnd(max_ts, time_base.den,
+                                time_base.num * (int64_t)AV_TIME_BASE,
+                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);
+    }
+
     return ff_subtitles_queue_seek(&vobsub->q, s, stream_index,
                                    min_ts, ts, max_ts, flags);
 }
diff --git a/lib/ffmpeg/libavformat/mpegts.c b/lib/ffmpeg/libavformat/mpegts.c
index 70242b1..abab514 100644
--- a/lib/ffmpeg/libavformat/mpegts.c
+++ b/lib/ffmpeg/libavformat/mpegts.c
@@ -1673,12 +1673,18 @@ static void pat_cb(MpegTSFilter *filter, const uint8_t *section, int section_len
         if (sid == 0x0000) {
             /* NIT info */
         } else {
+            MpegTSFilter *fil = ts->pids[pmt_pid];
             program = av_new_program(ts->stream, sid);
             program->program_num = sid;
             program->pmt_pid = pmt_pid;
-            if (ts->pids[pmt_pid])
-                mpegts_close_filter(ts, ts->pids[pmt_pid]);
-            mpegts_open_section_filter(ts, pmt_pid, pmt_cb, ts, 1);
+            if (fil)
+                if (   fil->type != MPEGTS_SECTION
+                    || fil->pid != pmt_pid
+                    || fil->u.section_filter.section_cb != pmt_cb)
+                    mpegts_close_filter(ts, ts->pids[pmt_pid]);
+
+            if (!ts->pids[pmt_pid])
+                mpegts_open_section_filter(ts, pmt_pid, pmt_cb, ts, 1);
             add_pat_entry(ts, sid);
             add_pid_to_pmt(ts, sid, 0); //add pat pid to program
             add_pid_to_pmt(ts, sid, pmt_pid);
diff --git a/lib/ffmpeg/libavformat/mpl2dec.c b/lib/ffmpeg/libavformat/mpl2dec.c
index ce2061b..2f708e0 100644
--- a/lib/ffmpeg/libavformat/mpl2dec.c
+++ b/lib/ffmpeg/libavformat/mpl2dec.c
@@ -43,7 +43,7 @@ static int mpl2_probe(AVProbeData *p)
         if (sscanf(ptr, "[%"PRId64"][%"PRId64"]%c", &start, &end, &c) != 3 &&
             sscanf(ptr, "[%"PRId64"][]%c",          &start,       &c) != 2)
             return 0;
-        ptr += strcspn(ptr, "\r\n") + 1;
+        ptr += ff_subtitles_next_line(ptr);
         if (ptr >= ptr_end)
             return 0;
     }
diff --git a/lib/ffmpeg/libavformat/mpsubdec.c b/lib/ffmpeg/libavformat/mpsubdec.c
index 2acafaa..360a3d8 100644
--- a/lib/ffmpeg/libavformat/mpsubdec.c
+++ b/lib/ffmpeg/libavformat/mpsubdec.c
@@ -37,12 +37,16 @@ static int mpsub_probe(AVProbeData *p)
     const char *ptr_end = p->buf + p->buf_size;
 
     while (ptr < ptr_end) {
+        int inc;
         int n;
 
         if (!memcmp(ptr, "FORMAT=TIME", 11) ||
             sscanf(ptr, "FORMAT=%d", &n) == 1)
             return AVPROBE_SCORE_MAX/2;
-        ptr += strcspn(ptr, "\n") + 1;
+        inc = ff_subtitles_next_line(ptr);
+        if (!inc)
+            break;
+        ptr += inc;
     }
     return 0;
 }
diff --git a/lib/ffmpeg/libavformat/mxfdec.c b/lib/ffmpeg/libavformat/mxfdec.c
index f7aaa5a..06aa8ac 100644
--- a/lib/ffmpeg/libavformat/mxfdec.c
+++ b/lib/ffmpeg/libavformat/mxfdec.c
@@ -1600,8 +1600,10 @@ static int mxf_parse_structural_metadata(MXFContext *mxf)
         }
         if (descriptor->extradata) {
             st->codec->extradata = av_mallocz(descriptor->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-            if (st->codec->extradata)
+            if (st->codec->extradata) {
                 memcpy(st->codec->extradata, descriptor->extradata, descriptor->extradata_size);
+                st->codec->extradata_size = descriptor->extradata_size;
+            }
         } else if(st->codec->codec_id == CODEC_ID_H264) {
             ff_generate_avci_extradata(st);
         }
diff --git a/lib/ffmpeg/libavformat/mxfenc.c b/lib/ffmpeg/libavformat/mxfenc.c
index cf9b77d..e9a870b 100644
--- a/lib/ffmpeg/libavformat/mxfenc.c
+++ b/lib/ffmpeg/libavformat/mxfenc.c
@@ -76,6 +76,7 @@ typedef struct {
     int temporal_reordering;
     AVRational aspect_ratio; ///< display aspect ratio
     int closed_gop;          ///< gop is closed, used in mpeg-2 frame parsing
+    int video_bit_rate;
 } MXFStreamContext;
 
 typedef struct {
@@ -976,13 +977,14 @@ static void mxf_write_cdci_desc(AVFormatContext *s, AVStream *st)
 static void mxf_write_mpegvideo_desc(AVFormatContext *s, AVStream *st)
 {
     AVIOContext *pb = s->pb;
+    MXFStreamContext *sc = st->priv_data;
     int profile_and_level = (st->codec->profile<<4) | st->codec->level;
 
     mxf_write_cdci_common(s, st, mxf_mpegvideo_descriptor_key, 8+5);
 
     // bit rate
     mxf_write_local_tag(pb, 4, 0x8000);
-    avio_wb32(pb, st->codec->bit_rate);
+    avio_wb32(pb, sc->video_bit_rate);
 
     // profile and level
     mxf_write_local_tag(pb, 1, 0x8007);
@@ -1705,14 +1707,15 @@ static int mxf_write_header(AVFormatContext *s)
                 ret = av_timecode_init(&mxf->tc, rate, 0, 0, s);
             if (ret < 0)
                 return ret;
+            sc->video_bit_rate = st->codec->bit_rate ? st->codec->bit_rate : st->codec->rc_max_rate;
             if (s->oformat == &ff_mxf_d10_muxer) {
-                if (st->codec->bit_rate == 50000000) {
+                if (sc->video_bit_rate == 50000000) {
                     if (mxf->time_base.den == 25) sc->index = 3;
                     else                          sc->index = 5;
-                } else if (st->codec->bit_rate == 40000000) {
+                } else if (sc->video_bit_rate == 40000000) {
                     if (mxf->time_base.den == 25) sc->index = 7;
                     else                          sc->index = 9;
-                } else if (st->codec->bit_rate == 30000000) {
+                } else if (sc->video_bit_rate == 30000000) {
                     if (mxf->time_base.den == 25) sc->index = 11;
                     else                          sc->index = 13;
                 } else {
@@ -1721,7 +1724,7 @@ static int mxf_write_header(AVFormatContext *s)
                 }
 
                 mxf->edit_unit_byte_count = KAG_SIZE; // system element
-                mxf->edit_unit_byte_count += 16 + 4 + (uint64_t)st->codec->bit_rate *
+                mxf->edit_unit_byte_count += 16 + 4 + (uint64_t)sc->video_bit_rate *
                     mxf->time_base.num / (8*mxf->time_base.den);
                 mxf->edit_unit_byte_count += klv_fill_size(mxf->edit_unit_byte_count);
                 mxf->edit_unit_byte_count += 16 + 4 + 4 + spf->samples_per_frame[0]*8*4;
@@ -1855,7 +1858,8 @@ static void mxf_write_d10_video_packet(AVFormatContext *s, AVStream *st, AVPacke
 {
     MXFContext *mxf = s->priv_data;
     AVIOContext *pb = s->pb;
-    int packet_size = (uint64_t)st->codec->bit_rate*mxf->time_base.num /
+    MXFStreamContext *sc = st->priv_data;
+    int packet_size = (uint64_t)sc->video_bit_rate*mxf->time_base.num /
         (8*mxf->time_base.den); // frame size
     int pad;
 
diff --git a/lib/ffmpeg/libavformat/oggparseskeleton.c b/lib/ffmpeg/libavformat/oggparseskeleton.c
index b6959a6..d94b0c2 100644
--- a/lib/ffmpeg/libavformat/oggparseskeleton.c
+++ b/lib/ffmpeg/libavformat/oggparseskeleton.c
@@ -37,6 +37,9 @@ static int skeleton_header(AVFormatContext *s, int idx)
     strcpy(st->codec->codec_name, "skeleton");
     st->codec->codec_type = AVMEDIA_TYPE_DATA;
 
+    if ((os->flags & OGG_FLAG_EOS) && os->psize == 0)
+        return 1;
+
     if (os->psize < 8)
         return -1;
 
@@ -74,12 +77,16 @@ static int skeleton_header(AVFormatContext *s, int idx)
 
         target_idx = ogg_find_stream(ogg, AV_RL32(buf+12));
         start_granule = AV_RL64(buf+36);
+        if (target_idx < 0) {
+            av_log(s, AV_LOG_WARNING, "Serial number in fisbone doesn't match any stream\n");
+            return 1;
+        }
+        os = ogg->streams + target_idx;
         if (os->start_granule != OGG_NOGRANULE_VALUE) {
-            av_log_missing_feature(s,
-                                   "Multiple fisbone for the same stream", 0);
+            av_log(s, AV_LOG_WARNING, "Multiple fisbone for the same stream\n");
             return 1;
         }
-        if (target_idx >= 0 && start_granule != OGG_NOGRANULE_VALUE) {
+        if (start_granule != OGG_NOGRANULE_VALUE) {
             os->start_granule = start_granule;
         }
     }
diff --git a/lib/ffmpeg/libavformat/paf.c b/lib/ffmpeg/libavformat/paf.c
index 09786eb..09aefe6 100644
--- a/lib/ffmpeg/libavformat/paf.c
+++ b/lib/ffmpeg/libavformat/paf.c
@@ -233,10 +233,11 @@ static int read_packet(AVFormatContext *s, AVPacket *pkt)
         p->current_frame_block++;
     }
 
-    size = p->video_size - p->frames_offset_table[p->current_frame];
-    if (size < 1)
+    if (p->frames_offset_table[p->current_frame] >= p->video_size)
         return AVERROR_INVALIDDATA;
 
+    size = p->video_size - p->frames_offset_table[p->current_frame];
+
     if (av_new_packet(pkt, size) < 0)
         return AVERROR(ENOMEM);
 
diff --git a/lib/ffmpeg/libavformat/rmdec.c b/lib/ffmpeg/libavformat/rmdec.c
index ee1e0ff..2edbfc3 100644
--- a/lib/ffmpeg/libavformat/rmdec.c
+++ b/lib/ffmpeg/libavformat/rmdec.c
@@ -95,13 +95,14 @@ static int rm_read_extradata(AVIOContext *pb, AVCodecContext *avctx, unsigned si
     return 0;
 }
 
-static void rm_read_metadata(AVFormatContext *s, int wide)
+static void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide)
 {
     char buf[1024];
     int i;
+
     for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) {
-        int len = wide ? avio_rb16(s->pb) : avio_r8(s->pb);
-        get_strl(s->pb, buf, sizeof(buf), len);
+        int len = wide ? avio_rb16(pb) : avio_r8(pb);
+        get_strl(pb, buf, sizeof(buf), len);
         av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0);
     }
 }
@@ -134,7 +135,7 @@ static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,
         avio_skip(pb, 8);
         bytes_per_minute = avio_rb16(pb);
         avio_skip(pb, 4);
-        rm_read_metadata(s, 0);
+        rm_read_metadata(s, pb, 0);
         if ((startpos + header_size) >= avio_tell(pb) + 2) {
             // fourcc (should always be "lpcJ")
             avio_r8(pb);
@@ -293,7 +294,7 @@ static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,
             avio_r8(pb);
             avio_r8(pb);
             avio_r8(pb);
-            rm_read_metadata(s, 0);
+            rm_read_metadata(s, pb, 0);
         }
     }
     return 0;
@@ -516,7 +517,7 @@ static int rm_read_header(AVFormatContext *s)
             flags = avio_rb16(pb); /* flags */
             break;
         case MKTAG('C', 'O', 'N', 'T'):
-            rm_read_metadata(s, 1);
+            rm_read_metadata(s, pb, 1);
             break;
         case MKTAG('M', 'D', 'P', 'R'):
             st = avformat_new_stream(s, NULL);
@@ -1000,6 +1001,18 @@ static int64_t rm_read_dts(AVFormatContext *s, int stream_index,
     return dts;
 }
 
+static int rm_read_seek(AVFormatContext *s, int stream_index,
+                        int64_t pts, int flags)
+{
+    RMDemuxContext *rm = s->priv_data;
+
+    if (ff_seek_frame_binary(s, stream_index, pts, flags) < 0)
+        return -1;
+    rm->audio_pkt_cnt = 0;
+    return 0;
+}
+
+
 AVInputFormat ff_rm_demuxer = {
     .name           = "rm",
     .long_name      = NULL_IF_CONFIG_SMALL("RealMedia"),
@@ -1009,6 +1022,7 @@ AVInputFormat ff_rm_demuxer = {
     .read_packet    = rm_read_packet,
     .read_close     = rm_read_close,
     .read_timestamp = rm_read_dts,
+    .read_seek      = rm_read_seek,
 };
 
 AVInputFormat ff_rdt_demuxer = {
diff --git a/lib/ffmpeg/libavformat/smacker.c b/lib/ffmpeg/libavformat/smacker.c
index 883a2b7..84481e2 100644
--- a/lib/ffmpeg/libavformat/smacker.c
+++ b/lib/ffmpeg/libavformat/smacker.c
@@ -276,7 +276,7 @@ static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)
                 } else if(t & 0x40){ /* copy with offset */
                     off = avio_r8(s->pb);
                     j = (t & 0x3F) + 1;
-                    if (off + j > 0xff) {
+                    if (off + j - 1 > 0xff) {
                         av_log(s, AV_LOG_ERROR,
                                "Invalid palette update, offset=%d length=%d extends beyond palette size\n",
                                off, j);
diff --git a/lib/ffmpeg/libavformat/srtdec.c b/lib/ffmpeg/libavformat/srtdec.c
index 76e06e4..ba79984 100644
--- a/lib/ffmpeg/libavformat/srtdec.c
+++ b/lib/ffmpeg/libavformat/srtdec.c
@@ -37,12 +37,14 @@ static int srt_probe(AVProbeData *p)
     if (AV_RB24(ptr) == 0xEFBBBF)
         ptr += 3;  /* skip UTF-8 BOM */
 
+    while (*ptr == '\r' || *ptr == '\n')
+        ptr++;
     for (i=0; i<2; i++) {
         if ((num == i || num + 1 == i)
             && sscanf(ptr, "%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d", &v) == 1)
             return AVPROBE_SCORE_MAX;
         num = atoi(ptr);
-        ptr += strcspn(ptr, "\n") + 1;
+        ptr += ff_subtitles_next_line(ptr);
     }
     return 0;
 }
@@ -63,10 +65,11 @@ static int64_t get_pts(const char **buf, int *duration,
             int64_t start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1;
             int64_t end   = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2;
             *duration = end - start;
-            *buf += strcspn(*buf, "\n") + 1;
+            *buf += ff_subtitles_next_line(*buf);
             return start;
         }
-        *buf += strcspn(*buf, "\n") + 1;
+        *buf += ff_subtitles_next_line(*buf);
+
     }
     return AV_NOPTS_VALUE;
 }
diff --git a/lib/ffmpeg/libavformat/subtitles.c b/lib/ffmpeg/libavformat/subtitles.c
index 37ba0cb..1634e3a 100644
--- a/lib/ffmpeg/libavformat/subtitles.c
+++ b/lib/ffmpeg/libavformat/subtitles.c
@@ -108,7 +108,8 @@ int ff_subtitles_queue_seek(FFDemuxSubtitlesQueue *q, AVFormatContext *s, int st
         for (i = 0; i < q->nb_subs; i++) {
             int64_t pts = q->subs[i].pts;
             uint64_t ts_diff = FFABS(pts - ts);
-            if (pts >= min_ts && pts <= max_ts && ts_diff < min_ts_diff) {
+            if ((stream_index == -1 || q->subs[i].stream_index == stream_index) &&
+                pts >= min_ts && pts <= max_ts && ts_diff < min_ts_diff) {
                 min_ts_diff = ts_diff;
                 idx = i;
             }
@@ -118,13 +119,25 @@ int ff_subtitles_queue_seek(FFDemuxSubtitlesQueue *q, AVFormatContext *s, int st
         /* look back in the latest subtitles for overlapping subtitles */
         ts_selected = q->subs[idx].pts;
         for (i = idx - 1; i >= 0; i--) {
-            if (q->subs[i].duration <= 0)
+            int64_t pts = q->subs[i].pts;
+            if (q->subs[i].duration <= 0 ||
+                (stream_index != -1 && q->subs[i].stream_index != stream_index))
                 continue;
-            if (q->subs[i].pts > ts_selected - q->subs[i].duration)
+            if (pts >= min_ts && pts > ts_selected - q->subs[i].duration)
                 idx = i;
             else
                 break;
         }
+
+        /* If the queue is used to store multiple subtitles streams (like with
+         * VobSub) and the stream index is not specified, we need to make sure
+         * to focus on the smallest file position offset for a same timestamp;
+         * queue is ordered by pts and then filepos, so we can take the first
+         * entry for a given timestamp. */
+        if (stream_index == -1)
+            while (idx > 0 && q->subs[idx - 1].pts == q->subs[idx].pts)
+                idx--;
+
         q->current_sub_idx = idx;
     }
     return 0;
diff --git a/lib/ffmpeg/libavformat/subtitles.h b/lib/ffmpeg/libavformat/subtitles.h
index 455b374..8f68e7b 100644
--- a/lib/ffmpeg/libavformat/subtitles.h
+++ b/lib/ffmpeg/libavformat/subtitles.h
@@ -96,4 +96,17 @@ const char *ff_smil_get_attr_ptr(const char *s, const char *attr);
  */
 void ff_subtitles_read_chunk(AVIOContext *pb, AVBPrint *buf);
 
+/**
+ * Get the number of characters to increment to jump to the next line, or to
+ * the end of the string.
+ */
+static av_always_inline int ff_subtitles_next_line(const char *ptr)
+{
+    int n = strcspn(ptr, "\n");
+    ptr += n;
+    if (*ptr == '\n')
+        n++;
+    return n;
+}
+
 #endif /* AVFORMAT_SUBTITLES_H */
diff --git a/lib/ffmpeg/libavformat/utils.c b/lib/ffmpeg/libavformat/utils.c
index e1b1433..335095d 100644
--- a/lib/ffmpeg/libavformat/utils.c
+++ b/lib/ffmpeg/libavformat/utils.c
@@ -1481,6 +1481,9 @@ static int read_frame_internal(AVFormatContext *s, AVPacket *pkt)
             st->skip_to_keyframe = 0;
         if (st->skip_to_keyframe) {
             av_free_packet(&cur_pkt);
+            if (got_packet) {
+                *pkt = cur_pkt;
+            }
             got_packet = 0;
         }
     }
@@ -1889,14 +1892,16 @@ int64_t ff_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts,
     }
 
     if(ts_max == AV_NOPTS_VALUE){
-        int step= 1024;
+        int64_t step= 1024;
+        int64_t limit;
         filesize = avio_size(s->pb);
         pos_max = filesize - 1;
         do{
+            limit = pos_max;
             pos_max = FFMAX(0, pos_max - step);
-            ts_max = ff_read_timestamp(s, stream_index, &pos_max, pos_max + step, read_timestamp);
+            ts_max = ff_read_timestamp(s, stream_index, &pos_max, limit, read_timestamp);
             step += step;
-        }while(ts_max == AV_NOPTS_VALUE && pos_max > 0);
+        }while(ts_max == AV_NOPTS_VALUE && 2*limit > step);
         if (ts_max == AV_NOPTS_VALUE)
             return -1;
 
diff --git a/lib/ffmpeg/libavformat/wavdec.c b/lib/ffmpeg/libavformat/wavdec.c
index 782fa64..87d3699 100644
--- a/lib/ffmpeg/libavformat/wavdec.c
+++ b/lib/ffmpeg/libavformat/wavdec.c
@@ -629,7 +629,7 @@ static int w64_read_header(AVFormatContext *s)
             uint32_t count, chunk_size, i;
 
             start = avio_tell(pb);
-            end = start + size;
+            end = start + FFALIGN(size, INT64_C(8)) - 24;
             count = avio_rl32(pb);
 
             for (i = 0; i < count; i++) {
@@ -655,7 +655,7 @@ static int w64_read_header(AVFormatContext *s)
             avio_skip(pb, end - avio_tell(pb));
         } else {
             av_log(s, AV_LOG_DEBUG, "unknown guid: "FF_PRI_GUID"\n", FF_ARG_GUID(guid));
-            avio_skip(pb, size - 24);
+            avio_skip(pb, FFALIGN(size, INT64_C(8)) - 24);
         }
     }
 
diff --git a/lib/ffmpeg/libavutil/intfloat_readwrite.c b/lib/ffmpeg/libavutil/intfloat_readwrite.c
index 2998229..142331d 100644
--- a/lib/ffmpeg/libavutil/intfloat_readwrite.c
+++ b/lib/ffmpeg/libavutil/intfloat_readwrite.c
@@ -26,6 +26,7 @@
  */
 
 #include <stdint.h>
+#include "common.h"
 #include "mathematics.h"
 #include "intfloat_readwrite.h"
 
@@ -88,7 +89,7 @@ AVExtFloat av_dbl2ext(double d){
             ext.mantissa[i] = m>>(56-(i<<3));
     } else if (f != 0.0) {
         ext.exponent[0] = 0x7f; ext.exponent[1] = 0xff;
-        if (f != INFINITY)
+        if (!isinf(f))
             ext.mantissa[0] = ~0;
     }
     if (d < 0)
diff --git a/lib/ffmpeg/libavutil/log.c b/lib/ffmpeg/libavutil/log.c
index 700e89f..49dd4d1 100644
--- a/lib/ffmpeg/libavutil/log.c
+++ b/lib/ffmpeg/libavutil/log.c
@@ -178,7 +178,7 @@ static void format_line(void *ptr, int level, const char *fmt, va_list vl,
             if (parent && *parent) {
                 snprintf(part[0], part_size, "[%s @ %p] ",
                          (*parent)->item_name(parent), parent);
-                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);
+                if(type) type[0] = get_category(parent);
             }
         }
         snprintf(part[1], part_size, "[%s @ %p] ",
diff --git a/lib/ffmpeg/libswresample/rematrix.c b/lib/ffmpeg/libswresample/rematrix.c
index 8ab554c..e56dc35 100644
--- a/lib/ffmpeg/libswresample/rematrix.c
+++ b/lib/ffmpeg/libswresample/rematrix.c
@@ -78,9 +78,6 @@ static int even(int64_t layout){
 }
 
 static int clean_layout(SwrContext *s, int64_t layout){
-    if((layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == AV_CH_LAYOUT_STEREO_DOWNMIX)
-        return AV_CH_LAYOUT_STEREO;
-
     if(layout && layout != AV_CH_FRONT_CENTER && !(layout&(layout-1))) {
         char buf[128];
         av_get_channel_layout_string(buf, sizeof(buf), -1, layout);
@@ -119,13 +116,19 @@ av_cold static int auto_matrix(SwrContext *s)
     float maxval;
 
     in_ch_layout = clean_layout(s, s->in_ch_layout);
+    out_ch_layout = clean_layout(s, s->out_ch_layout);
+
+    if(   out_ch_layout == AV_CH_LAYOUT_STEREO_DOWNMIX
+       && (in_ch_layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == 0
+    )
+        out_ch_layout = AV_CH_LAYOUT_STEREO;
+
     if(!sane_layout(in_ch_layout)){
         av_get_channel_layout_string(buf, sizeof(buf), -1, s->in_ch_layout);
         av_log(s, AV_LOG_ERROR, "Input channel layout '%s' is not supported\n", buf);
         return AVERROR(EINVAL);
     }
 
-    out_ch_layout = clean_layout(s, s->out_ch_layout);
     if(!sane_layout(out_ch_layout)){
         av_get_channel_layout_string(buf, sizeof(buf), -1, s->out_ch_layout);
         av_log(s, AV_LOG_ERROR, "Output channel layout '%s' is not supported\n", buf);
diff --git a/lib/ffmpeg/libswresample/x86/audio_convert.asm b/lib/ffmpeg/libswresample/x86/audio_convert.asm
index ad46977..4963959 100644
--- a/lib/ffmpeg/libswresample/x86/audio_convert.asm
+++ b/lib/ffmpeg/libswresample/x86/audio_convert.asm
@@ -195,7 +195,12 @@ cglobal %2_to_%1_%3, 3, 3, 6, dst, src, len
     add lenq, 2*mmsize/(1<<%4)
 %endif
         jl .next
+%if mmsize == 8
+    emms
+    RET
+%else
     REP_RET
+%endif
 %endmacro
 
 %macro PACK_6CH 5-7
diff --git a/lib/ffmpeg/libswscale/input.c b/lib/ffmpeg/libswscale/input.c
index 2def2de..acf56b3 100644
--- a/lib/ffmpeg/libswscale/input.c
+++ b/lib/ffmpeg/libswscale/input.c
@@ -724,12 +724,13 @@ static av_always_inline void planar_rgb16_to_y(uint8_t *_dst, const uint8_t *_sr
     int i;
     const uint16_t **src = (const uint16_t **)_src;
     uint16_t *dst        = (uint16_t *)_dst;
+    int shift = bpc < 16 ? bpc : 14;
     for (i = 0; i < width; i++) {
         int g = rdpx(src[0] + i);
         int b = rdpx(src[1] + i);
         int r = rdpx(src[2] + i);
 
-        dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT + bpc - 9))) >> (RGB2YUV_SHIFT + bpc - 14));
+        dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT + bpc - 9))) >> (RGB2YUV_SHIFT + shift - 14));
     }
 }
 
@@ -791,13 +792,14 @@ static av_always_inline void planar_rgb16_to_uv(uint8_t *_dstU, uint8_t *_dstV,
     const uint16_t **src = (const uint16_t **)_src;
     uint16_t *dstU       = (uint16_t *)_dstU;
     uint16_t *dstV       = (uint16_t *)_dstV;
+    int shift = bpc < 16 ? bpc : 14;
     for (i = 0; i < width; i++) {
         int g = rdpx(src[0] + i);
         int b = rdpx(src[1] + i);
         int r = rdpx(src[2] + i);
 
-        dstU[i] = (RU * r + GU * g + BU * b + (257 << (RGB2YUV_SHIFT + bpc - 9))) >> (RGB2YUV_SHIFT + bpc - 14);
-        dstV[i] = (RV * r + GV * g + BV * b + (257 << (RGB2YUV_SHIFT + bpc - 9))) >> (RGB2YUV_SHIFT + bpc - 14);
+        dstU[i] = (RU * r + GU * g + BU * b + (257 << (RGB2YUV_SHIFT + bpc - 9))) >> (RGB2YUV_SHIFT + shift - 14);
+        dstV[i] = (RV * r + GV * g + BV * b + (257 << (RGB2YUV_SHIFT + bpc - 9))) >> (RGB2YUV_SHIFT + shift - 14);
     }
 }
 #undef rdpx
diff --git a/lib/ffmpeg/tests/ref/fate/h264-conformance-canl1_toshiba_g b/lib/ffmpeg/tests/ref/fate/h264-conformance-canl1_toshiba_g
new file mode 100644
index 0000000..ced4c92
--- /dev/null
+++ b/lib/ffmpeg/tests/ref/fate/h264-conformance-canl1_toshiba_g
@@ -0,0 +1,301 @@
+#tb 0: 1/25
+0,          0,          0,        1,    38016, 0x58892149
+0,          1,          1,        1,    38016, 0xda2ded74
+0,          2,          2,        1,    38016, 0x2661cdb0
+0,          3,          3,        1,    38016, 0xb581a73a
+0,          4,          4,        1,    38016, 0xa04a7e93
+0,          5,          5,        1,    38016, 0x149e7861
+0,          6,          6,        1,    38016, 0x53725080
+0,          7,          7,        1,    38016, 0x341a4d3f
+0,          8,          8,        1,    38016, 0x2ecc41ac
+0,          9,          9,        1,    38016, 0x99b85127
+0,         10,         10,        1,    38016, 0x7bdc50bc
+0,         11,         11,        1,    38016, 0xd3d58663
+0,         12,         12,        1,    38016, 0x717485e9
+0,         13,         13,        1,    38016, 0x2ac29c85
+0,         14,         14,        1,    38016, 0x36daa429
+0,         15,         15,        1,    38016, 0x8bb7a48e
+0,         16,         16,        1,    38016, 0xb38aab11
+0,         17,         17,        1,    38016, 0xacd89c4c
+0,         18,         18,        1,    38016, 0x676b71e1
+0,         19,         19,        1,    38016, 0xa2e7731e
+0,         20,         20,        1,    38016, 0x4a2f5766
+0,         21,         21,        1,    38016, 0x04ef1873
+0,         22,         22,        1,    38016, 0x52ac0171
+0,         23,         23,        1,    38016, 0xdd0a027a
+0,         24,         24,        1,    38016, 0x700810c6
+0,         25,         25,        1,    38016, 0x417f0cd3
+0,         26,         26,        1,    38016, 0xf8ef0da9
+0,         27,         27,        1,    38016, 0xfce62a5a
+0,         28,         28,        1,    38016, 0x03592b0a
+0,         29,         29,        1,    38016, 0x9b7b5373
+0,         30,         30,        1,    38016, 0xab015505
+0,         31,         31,        1,    38016, 0xf3387ae1
+0,         32,         32,        1,    38016, 0x1d09a5b6
+0,         33,         33,        1,    38016, 0x9159a5e2
+0,         34,         34,        1,    38016, 0x8887c177
+0,         35,         35,        1,    38016, 0x914dbacd
+0,         36,         36,        1,    38016, 0xaa97c0f6
+0,         37,         37,        1,    38016, 0x0837b14a
+0,         38,         38,        1,    38016, 0x0198be16
+0,         39,         39,        1,    38016, 0xc14bc9c6
+0,         40,         40,        1,    38016, 0xdb58c2a7
+0,         41,         41,        1,    38016, 0xa751ae90
+0,         42,         42,        1,    38016, 0x5813a64d
+0,         43,         43,        1,    38016, 0x73959f9b
+0,         44,         44,        1,    38016, 0xb0de8994
+0,         45,         45,        1,    38016, 0x79ea9214
+0,         46,         46,        1,    38016, 0x0b388957
+0,         47,         47,        1,    38016, 0x31aa91c9
+0,         48,         48,        1,    38016, 0xadcf88ec
+0,         49,         49,        1,    38016, 0x5bc99b68
+0,         50,         50,        1,    38016, 0x535e7c2e
+0,         51,         51,        1,    38016, 0xbfef8e0a
+0,         52,         52,        1,    38016, 0xc56285aa
+0,         53,         53,        1,    38016, 0x76758edc
+0,         54,         54,        1,    38016, 0xd8c3a20b
+0,         55,         55,        1,    38016, 0xd2aa918b
+0,         56,         56,        1,    38016, 0xfe1ea23b
+0,         57,         57,        1,    38016, 0x3533a68d
+0,         58,         58,        1,    38016, 0xd8679427
+0,         59,         59,        1,    38016, 0x76be9c98
+0,         60,         60,        1,    38016, 0xc37a9a7a
+0,         61,         61,        1,    38016, 0x1ebe9463
+0,         62,         62,        1,    38016, 0xab4c63d2
+0,         63,         63,        1,    38016, 0x761b3c50
+0,         64,         64,        1,    38016, 0xb57c4bb7
+0,         65,         65,        1,    38016, 0x86117755
+0,         66,         66,        1,    38016, 0xd89dacf3
+0,         67,         67,        1,    38016, 0x8940eee9
+0,         68,         68,        1,    38016, 0x2f7c3abf
+0,         69,         69,        1,    38016, 0x98366678
+0,         70,         70,        1,    38016, 0x14348147
+0,         71,         71,        1,    38016, 0x4e3ba8f8
+0,         72,         72,        1,    38016, 0xc167c205
+0,         73,         73,        1,    38016, 0x0581e211
+0,         74,         74,        1,    38016, 0x62cd0ea6
+0,         75,         75,        1,    38016, 0x753b3a2b
+0,         76,         76,        1,    38016, 0x25ce507a
+0,         77,         77,        1,    38016, 0x726f64af
+0,         78,         78,        1,    38016, 0xa13c7c58
+0,         79,         79,        1,    38016, 0xa27b7584
+0,         80,         80,        1,    38016, 0x45b47c12
+0,         81,         81,        1,    38016, 0x0f6a9456
+0,         82,         82,        1,    38016, 0x30ae9e92
+0,         83,         83,        1,    38016, 0xf59fa16d
+0,         84,         84,        1,    38016, 0x16d292d7
+0,         85,         85,        1,    38016, 0x828791cc
+0,         86,         86,        1,    38016, 0x71769267
+0,         87,         87,        1,    38016, 0xf297a0e0
+0,         88,         88,        1,    38016, 0x33a4a00a
+0,         89,         89,        1,    38016, 0xda96c5b8
+0,         90,         90,        1,    38016, 0x742daf25
+0,         91,         91,        1,    38016, 0x603f8bba
+0,         92,         92,        1,    38016, 0x89d18e70
+0,         93,         93,        1,    38016, 0x8c2b8c29
+0,         94,         94,        1,    38016, 0x9ccf6983
+0,         95,         95,        1,    38016, 0x8ddd5a29
+0,         96,         96,        1,    38016, 0x5679718d
+0,         97,         97,        1,    38016, 0x28aa80b3
+0,         98,         98,        1,    38016, 0x3b08780e
+0,         99,         99,        1,    38016, 0x9e408cbc
+0,        100,        100,        1,    38016, 0xe7c18e94
+0,        101,        101,        1,    38016, 0xaba57f22
+0,        102,        102,        1,    38016, 0xd8826dc5
+0,        103,        103,        1,    38016, 0x2ed2710e
+0,        104,        104,        1,    38016, 0x59748443
+0,        105,        105,        1,    38016, 0x5076b247
+0,        106,        106,        1,    38016, 0xf6ae9bcd
+0,        107,        107,        1,    38016, 0x4d83d68f
+0,        108,        108,        1,    38016, 0x118ff589
+0,        109,        109,        1,    38016, 0x65b3f2c0
+0,        110,        110,        1,    38016, 0x8f341576
+0,        111,        111,        1,    38016, 0xbeac1816
+0,        112,        112,        1,    38016, 0x19073cf9
+0,        113,        113,        1,    38016, 0xcfdb2e55
+0,        114,        114,        1,    38016, 0x99fd08f8
+0,        115,        115,        1,    38016, 0x025c0249
+0,        116,        116,        1,    38016, 0x4d311afc
+0,        117,        117,        1,    38016, 0xef532038
+0,        118,        118,        1,    38016, 0x7c353d9a
+0,        119,        119,        1,    38016, 0x9fed4678
+0,        120,        120,        1,    38016, 0x67062dad
+0,        121,        121,        1,    38016, 0x1e5b2069
+0,        122,        122,        1,    38016, 0x8b25fd3f
+0,        123,        123,        1,    38016, 0x06a9e566
+0,        124,        124,        1,    38016, 0x263badf5
+0,        125,        125,        1,    38016, 0x35a99a45
+0,        126,        126,        1,    38016, 0x930a8491
+0,        127,        127,        1,    38016, 0xf9d49dfd
+0,        128,        128,        1,    38016, 0xbc8cb0a6
+0,        129,        129,        1,    38016, 0x8f10d1a9
+0,        130,        130,        1,    38016, 0xb6dbc51b
+0,        131,        131,        1,    38016, 0x2f1bc747
+0,        132,        132,        1,    38016, 0xecdac1ac
+0,        133,        133,        1,    38016, 0x6391bdcc
+0,        134,        134,        1,    38016, 0x7e5eb209
+0,        135,        135,        1,    38016, 0x8f5ea1e8
+0,        136,        136,        1,    38016, 0x969195a9
+0,        137,        137,        1,    38016, 0x18579903
+0,        138,        138,        1,    38016, 0x4cfe8893
+0,        139,        139,        1,    38016, 0x68c57143
+0,        140,        140,        1,    38016, 0x297f6420
+0,        141,        141,        1,    38016, 0x36b1669c
+0,        142,        142,        1,    38016, 0x3d78362e
+0,        143,        143,        1,    38016, 0xaba14c36
+0,        144,        144,        1,    38016, 0xe6914a59
+0,        145,        145,        1,    38016, 0x3733481a
+0,        146,        146,        1,    38016, 0xb6df4c6d
+0,        147,        147,        1,    38016, 0x20631838
+0,        148,        148,        1,    38016, 0x014df835
+0,        149,        149,        1,    38016, 0xcb36db94
+0,        150,        150,        1,    38016, 0x4cb8b44a
+0,        151,        151,        1,    38016, 0xa49da6e5
+0,        152,        152,        1,    38016, 0x8dbfb72d
+0,        153,        153,        1,    38016, 0x3ba5b7d5
+0,        154,        154,        1,    38016, 0xc8ebad2d
+0,        155,        155,        1,    38016, 0x36fad594
+0,        156,        156,        1,    38016, 0x6302f0f2
+0,        157,        157,        1,    38016, 0xc799139e
+0,        158,        158,        1,    38016, 0x947947d0
+0,        159,        159,        1,    38016, 0x39756224
+0,        160,        160,        1,    38016, 0x1d995e51
+0,        161,        161,        1,    38016, 0x56274435
+0,        162,        162,        1,    38016, 0x3cfc2b1d
+0,        163,        163,        1,    38016, 0x5a4a178f
+0,        164,        164,        1,    38016, 0xca212af1
+0,        165,        165,        1,    38016, 0x885af884
+0,        166,        166,        1,    38016, 0x3241c9c1
+0,        167,        167,        1,    38016, 0x4ef997a4
+0,        168,        168,        1,    38016, 0x5ecb8030
+0,        169,        169,        1,    38016, 0x2eb76daa
+0,        170,        170,        1,    38016, 0x485780ba
+0,        171,        171,        1,    38016, 0xf5f88241
+0,        172,        172,        1,    38016, 0x563f97d0
+0,        173,        173,        1,    38016, 0x4a01a6c4
+0,        174,        174,        1,    38016, 0xd7ea8457
+0,        175,        175,        1,    38016, 0x08ae6916
+0,        176,        176,        1,    38016, 0x4c933e75
+0,        177,        177,        1,    38016, 0x49541e4a
+0,        178,        178,        1,    38016, 0xd14e028a
+0,        179,        179,        1,    38016, 0xabd5f4e6
+0,        180,        180,        1,    38016, 0xfe3bdd0f
+0,        181,        181,        1,    38016, 0xbb30cef4
+0,        182,        182,        1,    38016, 0xd724d0e3
+0,        183,        183,        1,    38016, 0x7537d6bf
+0,        184,        184,        1,    38016, 0x3da3e67a
+0,        185,        185,        1,    38016, 0xf02606eb
+0,        186,        186,        1,    38016, 0x2dde399b
+0,        187,        187,        1,    38016, 0xafe94c86
+0,        188,        188,        1,    38016, 0x923d6081
+0,        189,        189,        1,    38016, 0x9c733e4e
+0,        190,        190,        1,    38016, 0x2b16d821
+0,        191,        191,        1,    38016, 0x1edf9cd1
+0,        192,        192,        1,    38016, 0xa9c3b601
+0,        193,        193,        1,    38016, 0x9adeb02b
+0,        194,        194,        1,    38016, 0xf5eaddc3
+0,        195,        195,        1,    38016, 0xac871bea
+0,        196,        196,        1,    38016, 0x060429f4
+0,        197,        197,        1,    38016, 0xf80b421d
+0,        198,        198,        1,    38016, 0x7dcd6c50
+0,        199,        199,        1,    38016, 0x46e46798
+0,        200,        200,        1,    38016, 0xdbee759f
+0,        201,        201,        1,    38016, 0xbbe78774
+0,        202,        202,        1,    38016, 0xb85990ed
+0,        203,        203,        1,    38016, 0xda0e8530
+0,        204,        204,        1,    38016, 0x5eaf8508
+0,        205,        205,        1,    38016, 0x5c2c83fa
+0,        206,        206,        1,    38016, 0x6dfe9322
+0,        207,        207,        1,    38016, 0xa3059a60
+0,        208,        208,        1,    38016, 0x357c8237
+0,        209,        209,        1,    38016, 0xccae6b20
+0,        210,        210,        1,    38016, 0x25fe57c1
+0,        211,        211,        1,    38016, 0xfa65376b
+0,        212,        212,        1,    38016, 0xd9b12ef8
+0,        213,        213,        1,    38016, 0x3ab73fa0
+0,        214,        214,        1,    38016, 0xcb6a2f96
+0,        215,        215,        1,    38016, 0x8a973915
+0,        216,        216,        1,    38016, 0x71ac1dd2
+0,        217,        217,        1,    38016, 0x71802085
+0,        218,        218,        1,    38016, 0x4de728d9
+0,        219,        219,        1,    38016, 0xdf3a1de7
+0,        220,        220,        1,    38016, 0x36270e93
+0,        221,        221,        1,    38016, 0x90d4fe93
+0,        222,        222,        1,    38016, 0x3477fb4e
+0,        223,        223,        1,    38016, 0xd410fa81
+0,        224,        224,        1,    38016, 0xfc230675
+0,        225,        225,        1,    38016, 0xbda40c03
+0,        226,        226,        1,    38016, 0x7a47fc07
+0,        227,        227,        1,    38016, 0x53fe2a37
+0,        228,        228,        1,    38016, 0x342d3bec
+0,        229,        229,        1,    38016, 0xf13163a3
+0,        230,        230,        1,    38016, 0x03f087da
+0,        231,        231,        1,    38016, 0xbc03c466
+0,        232,        232,        1,    38016, 0x6318d676
+0,        233,        233,        1,    38016, 0xbc2f0b68
+0,        234,        234,        1,    38016, 0xcb57354b
+0,        235,        235,        1,    38016, 0x7e9a5b48
+0,        236,        236,        1,    38016, 0x9dca693a
+0,        237,        237,        1,    38016, 0xd0776497
+0,        238,        238,        1,    38016, 0x05a24093
+0,        239,        239,        1,    38016, 0x69b21063
+0,        240,        240,        1,    38016, 0x15f3ed8b
+0,        241,        241,        1,    38016, 0x2417bc52
+0,        242,        242,        1,    38016, 0xabc2a564
+0,        243,        243,        1,    38016, 0x67f2dd90
+0,        244,        244,        1,    38016, 0xa5fe4b6e
+0,        245,        245,        1,    38016, 0x7801add2
+0,        246,        246,        1,    38016, 0xf4abc321
+0,        247,        247,        1,    38016, 0x1d06a837
+0,        248,        248,        1,    38016, 0x2e0d6fc2
+0,        249,        249,        1,    38016, 0xc4f30535
+0,        250,        250,        1,    38016, 0x67d09a80
+0,        251,        251,        1,    38016, 0xca505a1e
+0,        252,        252,        1,    38016, 0x2e2e56c8
+0,        253,        253,        1,    38016, 0x689ea3e2
+0,        254,        254,        1,    38016, 0x9989165a
+0,        255,        255,        1,    38016, 0xd8e2c30e
+0,        256,        256,        1,    38016, 0x2a98bf3f
+0,        257,        257,        1,    38016, 0x44664d3e
+0,        258,        258,        1,    38016, 0x53a939de
+0,        259,        259,        1,    38016, 0x4c153702
+0,        260,        260,        1,    38016, 0x03c73e88
+0,        261,        261,        1,    38016, 0x7cd649d4
+0,        262,        262,        1,    38016, 0x7d7c5687
+0,        263,        263,        1,    38016, 0x8f3c53a6
+0,        264,        264,        1,    38016, 0x24634dd1
+0,        265,        265,        1,    38016, 0x5d00442c
+0,        266,        266,        1,    38016, 0xdcc72906
+0,        267,        267,        1,    38016, 0x5def12f3
+0,        268,        268,        1,    38016, 0x95e6e8be
+0,        269,        269,        1,    38016, 0x2675c694
+0,        270,        270,        1,    38016, 0x906aa24e
+0,        271,        271,        1,    38016, 0x09468fe4
+0,        272,        272,        1,    38016, 0xaec9736d
+0,        273,        273,        1,    38016, 0xa5812142
+0,        274,        274,        1,    38016, 0x9986d55f
+0,        275,        275,        1,    38016, 0x9f7fc399
+0,        276,        276,        1,    38016, 0xc345d526
+0,        277,        277,        1,    38016, 0x3ae3b9bd
+0,        278,        278,        1,    38016, 0xb103ec45
+0,        279,        279,        1,    38016, 0x3ff462c2
+0,        280,        280,        1,    38016, 0x5c07ed68
+0,        281,        281,        1,    38016, 0xccbad189
+0,        282,        282,        1,    38016, 0x6f3f9a18
+0,        283,        283,        1,    38016, 0x26406fa1
+0,        284,        284,        1,    38016, 0x06cf5f62
+0,        285,        285,        1,    38016, 0x3eb29bd1
+0,        286,        286,        1,    38016, 0x12ab807e
+0,        287,        287,        1,    38016, 0x7621bf0d
+0,        288,        288,        1,    38016, 0x88eabc0c
+0,        289,        289,        1,    38016, 0x21386662
+0,        290,        290,        1,    38016, 0x5839e3e4
+0,        291,        291,        1,    38016, 0xd196ee7c
+0,        292,        292,        1,    38016, 0x84dc8477
+0,        293,        293,        1,    38016, 0xbf2dcc7a
+0,        294,        294,        1,    38016, 0x29e3fe96
+0,        295,        295,        1,    38016, 0xf115ffc3
+0,        296,        296,        1,    38016, 0x7585d699
+0,        297,        297,        1,    38016, 0x7a7dcb8a
+0,        298,        298,        1,    38016, 0x03cfdb04
+0,        299,        299,        1,    38016, 0xd56e028c
diff --git a/lib/ffmpeg/tests/ref/fate/h264-conformance-cvmaqp2_sony_g b/lib/ffmpeg/tests/ref/fate/h264-conformance-cvmaqp2_sony_g
new file mode 100644
index 0000000..886ea4c
--- /dev/null
+++ b/lib/ffmpeg/tests/ref/fate/h264-conformance-cvmaqp2_sony_g
@@ -0,0 +1,18 @@
+#tb 0: 1/25
+0,          0,          0,        1,    36864, 0xdee3d4e3
+0,          1,          1,        1,    36864, 0xaa1a67ca
+0,          2,          2,        1,    36864, 0xe00e0dec
+0,          3,          3,        1,    36864, 0x31f0b63f
+0,          4,          4,        1,    36864, 0xd0cc34d9
+0,          5,          5,        1,    36864, 0x3e76eba5
+0,          6,          6,        1,    36864, 0x0e7dcc9c
+0,          7,          7,        1,    36864, 0xd71bc457
+0,          8,          8,        1,    36864, 0x11c81ebe
+0,          9,          9,        1,    36864, 0x1d4ca6d7
+0,         10,         10,        1,    36864, 0xb191d155
+0,         11,         11,        1,    36864, 0x435a188c
+0,         12,         12,        1,    36864, 0x99d7227c
+0,         13,         13,        1,    36864, 0x700637fc
+0,         14,         14,        1,    36864, 0x351f7dd3
+0,         15,         15,        1,    36864, 0x1658c18b
+0,         16,         16,        1,    36864, 0x60034b90
diff --git a/lib/ffmpeg/tests/ref/fate/sub-charenc b/lib/ffmpeg/tests/ref/fate/sub-charenc
index 3c4825e..ef72754 100644
--- a/lib/ffmpeg/tests/ref/fate/sub-charenc
+++ b/lib/ffmpeg/tests/ref/fate/sub-charenc
@@ -1 +1 @@
-a39d7e299a8e25b4ffece0f8d64bf19e
+9615088d613931b50fd5016c7535b99a
diff --git a/lib/ffmpeg/tests/ref/lavf/dpx b/lib/ffmpeg/tests/ref/lavf/dpx
index 5961e00..0206bd7 100644
--- a/lib/ffmpeg/tests/ref/lavf/dpx
+++ b/lib/ffmpeg/tests/ref/lavf/dpx
@@ -1,9 +1,9 @@
-808ea110635774252439722a48329d61 *./tests/data/images/dpx/02.dpx
+d2f0b4e854fda2d3b3bee84cef80593c *./tests/data/images/dpx/02.dpx
 ./tests/data/images/dpx/%02d.dpx CRC=0x6da01946
 305792 ./tests/data/images/dpx/02.dpx
-5e1a777fa3f4094c9c4dd989cf9e8e8b *./tests/data/images/dpx/02.dpx
+075963c3c08978b6a20555ba09161434 *./tests/data/images/dpx/02.dpx
 ./tests/data/images/dpx/%02d.dpx CRC=0xe5b9c023
 609920 ./tests/data/images/dpx/02.dpx
-13dc41b1e1e36399a5e1f8b7e3344a81 *./tests/data/images/dpx/02.dpx
+b9f22728f8ff393bf30cf6cbd624fa95 *./tests/data/images/dpx/02.dpx
 ./tests/data/images/dpx/%02d.dpx CRC=0xb6310a70
 407168 ./tests/data/images/dpx/02.dpx
diff --git a/lib/ffmpeg/tests/ref/lavf/mkv b/lib/ffmpeg/tests/ref/lavf/mkv
index 64979b2..be474a4 100644
--- a/lib/ffmpeg/tests/ref/lavf/mkv
+++ b/lib/ffmpeg/tests/ref/lavf/mkv
@@ -1,6 +1,6 @@
-b53f31e572394f225aff0bc82b5d1cc9 *./tests/data/lavf/lavf.mkv
-472553 ./tests/data/lavf/lavf.mkv
+1748c0b3221977509c62a158236d2492 *./tests/data/lavf/lavf.mkv
+472533 ./tests/data/lavf/lavf.mkv
 ./tests/data/lavf/lavf.mkv CRC=0x4780846b
-84dcb326fe85aeeb5768beb44372f248 *./tests/data/lavf/lavf.mkv
-320297 ./tests/data/lavf/lavf.mkv
+0f78dd9299210a51b18faafc971e71f2 *./tests/data/lavf/lavf.mkv
+320265 ./tests/data/lavf/lavf.mkv
 ./tests/data/lavf/lavf.mkv CRC=0x4780846b
diff --git a/lib/ffmpeg/tests/ref/seek/lavf-mkv b/lib/ffmpeg/tests/ref/seek/lavf-mkv
index 681462c..f03bcf8 100644
--- a/lib/ffmpeg/tests/ref/seek/lavf-mkv
+++ b/lib/ffmpeg/tests/ref/seek/lavf-mkv
@@ -1,48 +1,48 @@
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    555 size:   208
+ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    523 size:   208
 ret: 0         st:-1 flags:0  ts:-1.000000
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
 ret: 0         st:-1 flags:1  ts: 1.894167
-ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292185 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292153 size: 27834
 ret: 0         st: 0 flags:0  ts: 0.788000
-ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292185 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292153 size: 27834
 ret: 0         st: 0 flags:1  ts:-0.317000
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
 ret:-1         st: 1 flags:0  ts: 2.577000
 ret: 0         st: 1 flags:1  ts: 1.471000
-ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 320026 size:   209
+ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 319994 size:   209
 ret: 0         st:-1 flags:0  ts: 0.365002
-ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146738 size: 27925
+ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146706 size: 27925
 ret: 0         st:-1 flags:1  ts:-0.740831
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
 ret:-1         st: 0 flags:0  ts: 2.153000
 ret: 0         st: 0 flags:1  ts: 1.048000
-ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292185 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292153 size: 27834
 ret: 0         st: 1 flags:0  ts:-0.058000
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    555 size:   208
+ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    523 size:   208
 ret: 0         st: 1 flags:1  ts: 2.836000
-ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 320026 size:   209
+ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 319994 size:   209
 ret:-1         st:-1 flags:0  ts: 1.730004
 ret: 0         st:-1 flags:1  ts: 0.624171
-ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146738 size: 27925
+ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146706 size: 27925
 ret: 0         st: 0 flags:0  ts:-0.482000
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
 ret: 0         st: 0 flags:1  ts: 2.413000
-ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292185 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292153 size: 27834
 ret:-1         st: 1 flags:0  ts: 1.307000
 ret: 0         st: 1 flags:1  ts: 0.201000
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    555 size:   208
+ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    523 size:   208
 ret: 0         st:-1 flags:0  ts:-0.904994
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
 ret: 0         st:-1 flags:1  ts: 1.989173
-ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292185 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292153 size: 27834
 ret: 0         st: 0 flags:0  ts: 0.883000
-ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292185 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292153 size: 27834
 ret: 0         st: 0 flags:1  ts:-0.222000
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
 ret:-1         st: 1 flags:0  ts: 2.672000
 ret: 0         st: 1 flags:1  ts: 1.566000
-ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 320026 size:   209
+ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 319994 size:   209
 ret: 0         st:-1 flags:0  ts: 0.460008
-ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146738 size: 27925
+ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146706 size: 27925
 ret: 0         st:-1 flags:1  ts:-0.645825
-ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    771 size: 27837
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    739 size: 27837
